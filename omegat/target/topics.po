# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1999-2024, NLnet Labs
# This file is distributed under the same license as the Unbound package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr "Project-Id-Version: Unbound 1.19.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-12 13:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../source/topics/core/monitoring.rst:2
msgid "Monitoring and Reporting"
msgstr ""

#: ../../source/topics/core/monitoring.rst:4
msgid ""
"There are several ways to configure statistics in Unbound. In this "
"section we'll cover Munin and Cacti, but there are many other third-party"
" options available as well, using for example `Zabbix "
"<https://github.com/jeftedelima/Unbound-DNS>`_ or `Prometheus "
"<https://github.com/letsencrypt/unbound_exporter>`_."
msgstr ""

#: ../../source/topics/core/monitoring.rst:10
#: ../../source/topics/core/performance.rst:11
#: ../../source/topics/core/proxy.rst:32
msgid "Configuration"
msgstr ""

#: ../../source/topics/core/monitoring.rst:12
msgid ""
"Unbound has an option to enable extended statistics collection. If "
"enabled, more statistics are collected, for example what types of queries"
" are sent to the resolver. Otherwise, only the total number of queries is"
" collected."
msgstr ""

#: ../../source/topics/core/monitoring.rst:16
msgid ""
"Statistics can be printed to the log file using :ref:`statistics-"
"interval:<unbound.conf.statistics-interval>`, but here we'll focus on "
"using :doc:`/manpages/unbound-control` to obtain statistics on demand. If"
" you set a ``statistics-interval``, every interval it is printed to the "
"logfile."
msgstr ""

#: ../../source/topics/core/monitoring.rst:22
msgid ""
"To use ``unbound-control``, first set it up using the :ref:`unbound-"
"control-setup<manpages/unbound-control:Set Up>` script. See howto setup "
"unbound. Then you can use the :ref:`unbound-control stats<unbound-"
"control.commands.stats>` command to print out the statistics on demand."
msgstr ""

#: ../../source/topics/core/monitoring.rst:29
msgid ""
"Various graphing tools expect the counters to go up over time. Some may "
"expect counters to be reset to 0 since the previous statistics printout. "
"The :ref:`statistics-cumulative:<unbound.conf.statistics-cumulative>` "
"option controls the behaviour of Unbound. By default it is set to ``no``,"
" which resets values to zero after stat printout."
msgstr ""

#: ../../source/topics/core/monitoring.rst:46
msgid "Statistics with Munin"
msgstr ""

#: ../../source/topics/core/monitoring.rst:48
msgid ""
"In the ``contrib`` directory in the source of Unbound is the "
"``unbound_munin_`` plugin script. It can be used with `Munin <https"
"://munin-monitoring.org>`_ to monitor the health of an Unbound server."
msgstr ""

#: ../../source/topics/core/monitoring.rst:52
msgid ""
"Install ``munin`` and ``munin-node`` with the appropriate package install"
" tool. The plugin script for Unbound can be copied somewhere on the "
"system (such as in the unbound directory). Then create symbolic links "
"from ``/etc/munin/plugins`` to that file."
msgstr ""

#: ../../source/topics/core/monitoring.rst:61
msgid ""
"In the ``/etc/munin/plugin-conf.d/plugins.conf`` file you can setup the "
"Munin plugin for Unbound. Below are the default values. Set the correct "
"values for your system. The ``statefile`` is a temporary file."
msgstr ""

#: ../../source/topics/core/monitoring.rst:75
msgid ""
"Restart the munin-node daemon. Munin will automatically pick up the new "
"graph and plot it with ``rrdtool``."
msgstr ""

#: ../../source/topics/core/monitoring.rst:78
msgid ""
"Additional graphs are possible, below is a list of them, and examples. "
"Create (additional) symbolic links to ``unbound_munin_`` with the names "
"(in bold) of those graphs to enable their display. Several require that "
":ref:`extended-statistics:<unbound.conf.extended-statistics>` is enabled "
"in the configuration. Pictures included are samples, your statistics may "
"look different :-) ."
msgstr ""

#: ../../source/topics/core/monitoring.rst:87
msgid "unbound_munin_hits - base volume, cache hits, unwanted traffic"
msgstr ""

#: ../../source/topics/core/monitoring.rst:89
msgid ""
"A sharp increase in unwanted traffic indicates a possible spoof run in "
"progress."
msgstr ""

#: ../../source/topics/core/monitoring.rst:93
msgid "unbound_munin_queue - to monitor the internal requestlist"
msgstr ""

#: ../../source/topics/core/monitoring.rst:97
msgid "unbound_munin_memory - memory usage"
msgstr ""

#: ../../source/topics/core/monitoring.rst:99
msgid "You can see that the server was restarted during the day."
msgstr ""

#: ../../source/topics/core/monitoring.rst:103
msgid "unbound_munin_by_type - incoming queries by type"
msgstr ""

#: ../../source/topics/core/monitoring.rst:105
msgid "The types received are shown."
msgstr ""

#: ../../source/topics/core/monitoring.rst:109
msgid "unbound_munin_by_class - incoming queries by class"
msgstr ""

#: ../../source/topics/core/monitoring.rst:111
msgid "Usually only IN (internet) class."
msgstr ""

#: ../../source/topics/core/monitoring.rst:115
msgid "unbound_munin_by_opcode - incoming queries by opcode"
msgstr ""

#: ../../source/topics/core/monitoring.rst:117
msgid "Usually only QUERY (normal query)."
msgstr ""

#: ../../source/topics/core/monitoring.rst:121
msgid "unbound_munin_by_rcode - answers by rcode, validation status"
msgstr ""

#: ../../source/topics/core/monitoring.rst:125
msgid "unbound_munin_by_flags - incoming queries by flags"
msgstr ""

#: ../../source/topics/core/monitoring.rst:129
msgid "unbound_munin_histogram - histogram of query resolving times"
msgstr ""

#: ../../source/topics/core/monitoring.rst:132
msgid "Statistics with Cacti"
msgstr ""

#: ../../source/topics/core/monitoring.rst:134
msgid ""
"The setup is described in the README in the tarball in the Unbound source"
" ``contrib`` directory: :download:`contrib/unbound_cacti.tar.gz "
"<https://github.com/NLnetLabs/unbound/blob/master/contrib/unbound_cacti.tar.gz?raw=true>`"
" (contributed by Dmitriy Demidov)."
msgstr ""

#: ../../source/topics/core/monitoring.rst:139
msgid "Example output from unbound cacti statistics:"
msgstr ""

#: ../../source/topics/core/performance.rst:2
msgid "Performance Tuning"
msgstr ""

#: ../../source/topics/core/performance.rst:4
msgid ""
"Most users will probably not have a need to tune and optimise their "
"Unbound installation, but it could be useful for large resolver "
"installations. This page contains recommendations based on user feedback."
" If you have different experiences or have recommendations, please share "
"them on the `Unbound users mailing list "
"<https://lists.nlnetlabs.nl/mailman/listinfo/unbound-users>`_."
msgstr ""

#: ../../source/topics/core/performance.rst:13
msgid ""
"Set :ref:`num-threads:<unbound.conf.num-threads>` equal to the number of "
"CPU cores on the system. For example, for 4 CPUs with 2 cores each, use "
"8."
msgstr ""

#: ../../source/topics/core/performance.rst:17
msgid ""
"On Linux, set :ref:`so-reuseport: yes<unbound.conf.so-reuseport>`, that "
"will significantly improve UDP performance (on kernels that support it, "
"otherwise it is inactive, the :doc:`/manpages/unbound-control` status "
"command shows if it is active)."
msgstr ""

#: ../../source/topics/core/performance.rst:22
msgid ""
"Set ``*-slabs`` to a power of 2 close to the ``num-threads`` value. Do "
"this for :ref:`msg-cache-slabs:<unbound.conf.msg-cache-slabs>`, :ref"
":`rrset-cache-slabs:<unbound.conf.rrset-cache-slabs>`, :ref:`infra-cache-"
"slabs:<unbound.conf.infra-cache-slabs>` and :ref:`key-cache-"
"slabs:<unbound.conf.key-cache-slabs>`. This reduces lock contention."
msgstr ""

#: ../../source/topics/core/performance.rst:30
msgid ""
"Increase the memory size of the cache. Use roughly twice as much rrset "
"cache memory as you use msg cache memory. For example, :ref:`rrset-cache-"
"size: 100m<unbound.conf.rrset-cache-size>` and :ref:`msg-cache-size: "
"50m<unbound.conf.msg-cache-size>`. Due to malloc overhead, the total "
"memory usage is likely to rise to double (or 2.5x) the total cache memory"
" that is entered into the configuration."
msgstr ""

#: ../../source/topics/core/performance.rst:37
msgid ""
"Set the :ref:`outgoing-range:<unbound.conf.outgoing-range>` to as large a"
" value as possible, see the sections below on how to overcome the limit "
"of 1024 in total. This services more clients at a time. With 1 core, try "
"950. With 2 cores, try 450. With 4 cores try 200. The :ref:`num-queries-"
"per-thread:<unbound.conf.num-queries-per-thread>` is best set at half the"
" number of the ``outgoing-range``, but you would like a whole lot to be "
"able to soak up a spike in queries. Because of the limit on ``outgoing-"
"range`` thus also limits ``num-queries-per-thread``, it is better to "
"compile with ``libevent`` (see the section below), so that there is no "
"more 1024 limit on ``outgoing-range``."
msgstr ""

#: ../../source/topics/core/performance.rst:51
msgid ""
"Set :ref:`so-rcvbuf:<unbound.conf.so-rcvbuf>` to a larger value (4m or "
"8m) for a busy server. This sets the kernel buffer larger so that no "
"messages are lost in spikes in the traffic. Adds extra 9s to the reply-"
"reliability percentage. The OS caps it at a maximum, on Linux, Unbound "
"needs root permission to bypass the limit, or the admin can use ``sysctl "
"net.core.rmem_max``. On BSD change ``kern.ipc.maxsockbuf in "
"/etc/sysctl.conf``."
msgstr ""

#: ../../source/topics/core/performance.rst:60
msgid ""
"On OpenBSD change header and recompile kernel. On Solaris ``ndd -set "
"/dev/udp udp_max_buf 8388608``."
msgstr ""

#: ../../source/topics/core/performance.rst:63
msgid ""
"Also set :ref:`so-sndbuf:<unbound.conf.so-sndbuf>` to a larger value (4m "
"or 8m) for a busy server. Same as ``so-rcvbuf``, but now for spikes in "
"replies, and it is ``net.core.wmem_max``. Might need a smaller value, as "
"spikes are less common in replies, you can see rcv and snd buffer "
"overruns with ``netstat -su``, ``RcvbufErrors`` and ``SndbufErrors``, and"
" similar reports on BSD."
msgstr ""

#: ../../source/topics/core/performance.rst:71
msgid ""
"For the TCP listen backlog on Linux, it is possible to tweak the kernel "
"parameters to allow larger values. Unbound attempts to increase this to "
"enable it to handle spikes in incoming TCP or TLS connections. The number"
" that unbound attempts is defined in ``TCP_BACKLOG`` in "
"``services/listen_dnsport.c``, it does not need to be changed if the "
"current value, about 256, is sufficient for you. However, the Linux "
"kernel limits this value silently to a maximum configured into the kernel"
" settings. The kernel can be tweaked to enable a higher number with "
"``net.core.somaxconn = 256`` and ``net.ipv4.tcp_max_syn_backlog = 256``."
msgstr ""

#: ../../source/topics/core/performance.rst:80
msgid "Here is a short summary of optimisation config:"
msgstr ""

#: ../../source/topics/core/performance.rst:110
msgid ""
"The default setup works fine, but when a large number of users have to be"
" served, the limits of the system are reached. Most pressing is the "
"number of file descriptors, the default has a limit of 1024. To use more "
"than 1024 file descriptors, use libevent or the forked operation method. "
"These are described in sections below."
msgstr ""

#: ../../source/topics/core/performance.rst:117
msgid "Using Libevent"
msgstr ""

#: ../../source/topics/core/performance.rst:119
msgid ""
"Libevent is a BSD licensed cross platform wrapper around platform "
"specific event notification system calls. Unbound can use it to "
"efficiently use more than 1024 file descriptors. Install ``libevent`` "
"(and ``libevent-devel``, if it exists) with your favorite package "
"manager. Before compiling unbound run:"
msgstr ""

#: ../../source/topics/core/performance.rst:128
msgid ""
"Now you can give any number you like for :ref:`outgoing-"
"range:<unbound.conf.outgoing-range>`. Also increase the :ref:`num-"
"queries-per-thread:<unbound.conf.num-queries-per-thread>` value."
msgstr ""

#: ../../source/topics/core/performance.rst:139
msgid ""
"Users report that libevent-1.4.8-stable works well. Users have confirmed "
"it works well on Linux and FreeBSD with 4096 or 8192 as values. Double "
"the :ref:`num-queries-per-thread:<unbound.conf.num-queries-per-thread>` "
"and use that as :ref:`outgoing-range:<unbound.conf.outgoing-range>`."
msgstr ""

#: ../../source/topics/core/performance.rst:144
msgid ""
"Stable(old) distributions can package older versions (such as "
"libevent-1.1), for which there are crash reports, thus you may need to "
"upgrade your libevent. In unbound 1.2.0 a race condition in the libevent "
"calls was fixed."
msgstr ""

#: ../../source/topics/core/performance.rst:148
msgid ""
"Unbound can compile from the libevent or libev build directory to make "
"this easy; e.g.,"
msgstr ""

#: ../../source/topics/core/performance.rst:155
msgid "or"
msgstr ""

#: ../../source/topics/core/performance.rst:162
msgid ""
"If you experience crashes anyway, then you can try the following.  Update"
" libevent. If the problem persists, libevent can be made to use different"
" system-call back-ends by setting environment variables.  Unbound reports"
" the back-end in use when verbosity is at level 4. By setting "
"``EVENT_NOKQUEUE``, ``EVENT_NODEVPOLL``, ``EVENT_NOPOLL``, "
"``EVENT_NOSELECT``, ``EVENT_NOEPOLL`` or ``EVENT_NOEVPORT`` to yes in the"
" shell before you start unbound, some back-ends can be excluded from use."
" The *poll(2)* backend is reliable, but slow."
msgstr ""

#: ../../source/topics/core/performance.rst:172
msgid "Forked Operation"
msgstr ""

#: ../../source/topics/core/performance.rst:174
msgid ""
"Unbound has a unique mode where it can operate without threading. This "
"can be useful if libevent fails on the platform, for extra performance, "
"or for creating walls between the cores so that one cannot poison "
"another."
msgstr ""

#: ../../source/topics/core/performance.rst:178
msgid "To compile for forked operation, before compilation use:"
msgstr ""

#: ../../source/topics/core/performance.rst:184
msgid ""
"This disables threads and enable forked operation. Because no locking has"
" to be done, the code speeds up (about 10 to 20%)."
msgstr ""

#: ../../source/topics/core/performance.rst:187
msgid ""
"In the configuration file, :ref:`num-threads:<unbound.conf.num-threads>` "
"still specifies the number of cores you want to use (even though it uses "
"processes and not threads). And note that the :ref:`outgoing-"
"range:<unbound.conf.outgoing-range>` and cache memory values are all per "
"thread. This means that much more memory is used, as every core uses its "
"own cache. Because every core has its own cache, if one gets cache "
"poisoned, the others are not affected."
msgstr ""

#: ../../source/topics/core/performance.rst:220
msgid ""
"Because every process is using at most 1024 file descriptors now, the "
"effective maximum is the number of cores * 1024. The configuration above "
"uses 950 per process, for 4 processes gives a respectable 3800 sockets. "
"The number of queries per thread is half the number of sockets, to "
"guarantee that every query can get a socket, and some to spare for "
"queries-for-nameservers."
msgstr ""

#: ../../source/topics/core/performance.rst:226
msgid ""
"Using forked operation together with libevent is also possible. It may be"
" useful to force the OS to service the file descriptors for different "
"processes, instead of threads. This may have (radically) different "
"performance if the underlying network stack uses (slow) lookup structures"
" per-process."
msgstr ""

#: ../../source/topics/core/proxy.rst:4
msgid "Downstream Proxy Support"
msgstr ""

#: ../../source/topics/core/proxy.rst:6
msgid ""
"Since version 1.17.0, Unbound can play nicely in environments where "
"supported DNS reverse-proxying is in place. It is able to use the proxied"
" client information as the \"real\" client address for all functions, "
"except in the actual network communication, where a client address is "
"used, such as access control, logging, DNSTAP, RPZ and IP rate limiting."
msgstr ""

#: ../../source/topics/core/proxy.rst:13
msgid "The currently supported environment is PROXY protocol version 2 (PROXYv2)."
msgstr ""

#: ../../source/topics/core/proxy.rst:16
msgid "PROXYv2"
msgstr ""

#: ../../source/topics/core/proxy.rst:20
msgid ""
"Unbound supports PROXYv2 for downstream connections; that is clients "
"(read proxies) talking to Unbound."
msgstr ""

#: ../../source/topics/core/proxy.rst:23
msgid ""
"The PROXY protocol is protocol agnostic and can work with any layer 7 "
"protocol even when encrypted. It works on both UDP and TCP based "
"transports and in a nutshell it prepends the client information in the "
"application's payload. This is done once at the start of a TCP stream, or"
" in every UDP packet. The caveat is that both the proxy and the upstream "
"server (i.e., Unbound) need to understand the PROXY protocol."
msgstr ""

#: ../../source/topics/core/proxy.rst:34
msgid ""
"Configuring Unbound for PROXYv2 is pretty straight forward. The following"
" minimal configuration allows Unbound to listen for incoming queries on "
"port 53 (the default) and marks the same port as a PROXYv2 port:"
msgstr ""

#: ../../source/topics/core/proxy.rst:45
msgid "This means that Unbound **expects** PROXYv2 information on that port."
msgstr ""

#: ../../source/topics/core/proxy.rst:49
msgid ""
"In absence of a valid PROXYv2 header Unbound will terminate/drop the "
"connection/packet."
msgstr ""

#: ../../source/topics/core/proxy.rst:52
msgid ""
"The port configuration can be used alongside plain UDP and plain TCP "
"ports (as in the example above), but also together with DNS over TLS "
"ports."
msgstr ""

#: ../../source/topics/core/proxy.rst:57
msgid ""
"The coexistence of PROXYv2 together with either DNSCrypt or DNS over HTTP"
" is not supported."
msgstr ""

#: ../../source/topics/core/proxy.rst:61
msgid ""
":ref:`proxy-protocol-port<unbound.conf.proxy-protocol-port>` in the "
":doc:`/manpages/unbound.conf` manpage."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:2
msgid ":rfc:`8767` behavior is introduced"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:6
msgid "Serving Stale Data"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:8
msgid ""
"Unbound supports serving stale data from its cache, as described in "
":rfc:`8767`. Serving stale data would normally break the contract between"
" an authoritative name server and a caching resolver on the amount of "
"time a record is permitted to be cached. However, the TTL definition of "
":rfc:`8767#section-4` states that:"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:13
msgid ""
"\"If the data is unable to be authoritatively refreshed when the TTL "
"expires, the record MAY be used as though it is unexpired.\""
msgstr ""

#: ../../source/topics/core/serve-stale.rst:16
msgid ""
"Serving expired records is not a novel idea and it was already present in"
" various forms (e.g., increased cache-hit ratio, fallback when upstream "
"is not reachable) in various resolvers. Unbound’s own form is called :ref"
":`serve-expired:<unbound.conf.serve-expired>` and its main purpose was to"
" increase the cache-hit ratio."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:22
msgid ""
"As the RFC landed in the standards track, Unbound gained support for it "
"but still kept the original serve-expired logic. Certain aspects of the "
"RFC, such as timers, were already present in Unbound and their "
"functionality is shared by both modes of operation."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:27
msgid ""
"The following sections try to clarify the differences between serve-"
"expired and :rfc:`8767` (serve-stale) and give some insight into when one"
" may be preferable over the other. I will refrain from using the RFC term"
" serve-stale in order to avoid any confusion between the terms and the "
"configuration options later on."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:33
msgid "serve-expired"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:35
msgid ""
"Since version 1.6.0, Unbound has the ability to answer with expired "
"records. Before trying to resolve, Unbound will also consider expired "
"cached records as possible answers. If such a record is found it is "
"immediately returned to the client (cache response speed!). But contrary "
"to normal cache replies, Unbound continues resolving and hopefully "
"updating the cached record."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:41
msgid ""
"The immediate downside is obvious: the expired answers rely heavily on "
"the cache state. Unbound already has the tools to try and tip the scales "
"in its favor with the :ref:`prefetch:<unbound.conf.prefetch>` and :ref"
":`serve-expired-ttl:<unbound.conf.serve-expired-ttl>` options."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:47
#, python-format
msgid ""
"With prefetch, Unbound tries to update a cached record (after first "
"replying to the client) when the current TTL is within 10% of the "
"original TTL value. The logic is similar to serve-expired: if a cached "
"record is found and the record is within 10% of the TTL, it is returned "
"to the client but Unbound continues resolving in order to update the "
"record. Although prefetching comes with a small penalty of ~10% in "
"traffic and load from the extra upstream queries, the cache is kept up-"
"to-date, at least for popular queries."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:55
msgid ""
"Rare queries have the inescapable fate of having their records expired "
"past any meaningful time. The option :ref:`serve-expired-"
"ttl:<unbound.conf.serve-expired-ttl>` limits the amount of time an "
"expired record is supposed to be served. :rfc:`8767#section-5-11` "
"suggests a value between one and three days."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:63
msgid ""
"A note on the expired reply’s TTL value: prior to the RFC, Unbound was "
"using TTL 0 in order to signal that the expired record is only meant to "
"be used for this DNS transaction and not to be cached by the client. The "
"RFC now RECOMMENDS a value of 30 to be returned to the client."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:68
msgid ""
"A simple configuration for the primal serve-expired behavior could then "
"be:"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:77
msgid "This will allow Unbound to:"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:79
msgid "prioritize (expired) cached replies,"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:80
msgid "keep the cache fairly up-to-date, and"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:81
msgid ""
"in the likelihood that an expired record needs to be served (e.g., rare "
"query, issue with upstream resolving), make sure that the record is not "
"older than the specified limit."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:86
msgid "RFC 8767"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:88
msgid ""
"Starting with version 1.11.0, Unbound supports serving expired records "
"following the RFC guidelines. The RFC behavior is mainly focused on "
"returning expired answers as fallback for normal resolution. The option "
"to control that is :ref:`serve-expired-client-timeout:<unbound.conf"
".serve-expired-client-timeout>` and setting it to a value greater than 0 "
"enables the RFC behavior."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:96
msgid ""
"With the value set, Unbound has a limit on how much time it can spend "
"resolving a client query. When that limit is passed, Unbound pauses "
"resolution and checks if there are any expired records in the cache that "
"can answer the initial query. If that is the case, Unbound answers with "
"the expired record before resuming resolution. The result of the "
"resolution will be used to update the cache if possible."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:103
msgid ""
"Similar to the client timeout, Unbound will also try and use expired "
"answers instead of returning SERVFAIL to the client where possible."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:106
msgid "A simple configuration for the RFC behavior could then be:"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:116
msgid ""
"This will allow Unbound to use expired answers only as fallback from "
"normal resolving:"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:119
msgid "when 1.8 seconds have passed since the client made the query,"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:120
msgid "instead of returning SERVFAIL, or"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:121
msgid ""
"in the likelihood that an expired record needs to be served (e.g., issue "
"with upstream resolving), make sure that the record is not older than the"
" specified limit."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:126
msgid "Conclusion"
msgstr ""

#: ../../source/topics/core/serve-stale.rst:128
msgid ""
"Unbound offers two distinct modes for serving expired records. The safest"
" approach is to use the RFC behavior where expired records are used as a "
"fallback to availability, network or configuration errors. This will "
"serve expired records as a last resort instead of returning SERVFAIL or "
"the client giving up."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:133
msgid ""
"If more client-side performance is required, the default original serve-"
"expired behavior can keep the cache-hit ratio higher. Using it together "
"with the prefetch option is highly recommended in order to try and keep "
"an updated cache."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:137
msgid ""
"In all cases make sure to consult the :doc:`/manpages/unbound.conf` "
"manpage of your installed Unbound for defaults and suggested values. And "
"always remember that serving expired records should be approached with "
"caution; you may be directing your clients to places long gone."
msgstr ""

#: ../../source/topics/core/serve-stale.rst:143
msgid ""
":ref:`serve-expired<unbound.conf.serve-expired>`, :ref:`serve-expired-"
"ttl<unbound.conf.serve-expired-ttl>`, :ref:`serve-expired-ttl-"
"reset<unbound.conf.serve-expired-ttl-reset>`, :ref:`serve-expired-reply-"
"ttl<unbound.conf.serve-expired-reply-ttl>` and :ref:`serve-expired-"
"client-timeout<unbound.conf.serve-expired-client-timeout>` in the "
":doc:`/manpages/unbound.conf` manpage."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:3
msgid "Intial release with QNAME and Response IP Address triggers"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:5
msgid "Full set of RPZ triggers and actions are supported"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:9
msgid "Response Policy Zones"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:11
msgid ""
"Response Policy Zones (RPZ) is a mechanism that makes it possible to "
"define your local policies in a standardised way and load your policies "
"from external sources."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:16
#: ../../source/topics/privacy/aggressive-nsec.rst:12
msgid "Introduction"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:18
msgid ""
"Unbound has support for local-zone and local-data. This makes it possible"
" to give a custom answer back for specified domain names. It also "
"contains the ``respip`` module which makes it possible to rewrite answers"
" containing specified IP addresses. Although these options are heavily "
"used by users, they are Unbound specific. If you operate multiple "
"resolvers from multiple vendors you have to maintain your policies for "
"multiple configurations, which all will have their own syntax. Using the "
"Unbound specific configuration also makes it challenging to consume "
"policies from external sources."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:32
msgid ""
"To get these external sources to work manually, you have to fetch the "
"external policies in the offered format, reformat it in such a way that "
"Unbound will understand, and keep this list up-to-date, for example using"
" :doc:`/manpages/unbound-control`."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:37
msgid ""
"To automate this process in a generic, standardised way, Response Policy "
"Zones (RPZ) is a policy format that will work on different resolver "
"implementations, and that has capabilities to be directly transferred and"
" loaded from external sources."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:42
msgid ""
"We'll first discuss the different policies and RPZ actions with examples,"
" and then show how to implement RPZ in a configuration."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:48
msgid "RPZ Policies"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:56
msgid ""
"RPZ policies are formatted in DNS zone files. This makes it possible to "
"easily consume and keep them to up-to-date by using DNS zone transfers. "
"Something that Unbound is already capable of doing for its :ref:`auth-"
"zone<manpages/unbound.conf:Authority Zone Options>` feature."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:61
msgid ""
"Each policy in the policy zone consists of a trigger and an action. The "
"trigger describes when the policy should be applied. The action describes"
" what action should be taken if the policy needs to be applied. Each "
"trigger and action combination is defined as a Resource Record (RR) in "
"the policy zone. The owner of the RR states the trigger, the type and "
"RDATA state the action."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:67
msgid ""
"Unbound supports all the RPZ policies described in the  `RPZ internet "
"draft <https://tools.ietf.org/html/draft-vixie-dnsop-dns-rpz-00>`_:"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:71
msgid "Trigger"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:71
msgid "Description and example"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:73
msgid "``QNAME``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:73
msgid "The query name: ``example.com``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:75
msgid "``Client IP Address``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:75
msgid "The IP address of the client: ``24.0.2.0.192.rpz-client-ip``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:77
msgid "``Response IP Address``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:77
msgid "response IP address in the answer: ``24.0.2.0.192.rpz-ip``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:79
msgid "``NSDNAME``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:79
msgid "The nameserver name: ``ns.example.com.rpz-nsdname``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:81
msgid "``NSIP``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:81
msgid "The nameserver IP address: ``24.0.2.0.192.rpz-nsip``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:84
msgid ""
"Note that the IP address encoding for RPZ triggers in the IN-ADDR.ARPA "
"naming convention. So ``192.0.2.24`` will be written as ``24.2.0.192``."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:87
msgid "In the implementation step we will go trough all the triggers."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:92
msgid "RPZ Actions"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:94
msgid ""
"Aside from RPZ triggers, RPZ also specifies actions as a result of these "
"triggers. Unbound currently supports the following actions: **NXDOMAIN**,"
" **NODATA**, **PASSTHRU**, **DROP**, **Local Data**, and **TCP-only**."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:98
msgid ""
"The **Local Data** action responds with a preconfigured resource record. "
"Queries for types that do not exist in the policy zones will result in a "
"NODATA answer."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:120
msgid ""
"Other RPZ actions that are supported by Unbound are the **NXDOMAIN**, "
"**NODATA**, **PASSTHRU**, **DROP** and **TCP-Only** actions. All of these"
" actions are defined by having a CNAME to a specific name."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:144
msgid "The CNAME targets for the other RPZ actions are:"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:147
msgid "Action"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:147
msgid "RR type and RDATA"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:149
msgid "``NXDOMAIN``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:149
msgid "``CNAME .``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:151
msgid "``NODATA``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:151
msgid "``CNAME *.``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:153
msgid "``PASSTHRU``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:153
msgid "``CNAME rpz-passthru.``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:155
msgid "``DROP``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:155
msgid "``CNAME rpz-drop.``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:157
msgid "``TCP-Only``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:157
msgid "``CNAME rpz-tcp-only.``"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:160
msgid ""
"The **NODATA** action returns a response with no attached data. The "
"**DROP** action ignores (drops) the query. The **TCP-Only** action "
"responds to the query over TCP. The **PASSTHRU** action makes it possible"
" to exclude a domain, or IP address, from your policies so that if the "
"**PASSTHRU** action is triggered no other policy from any of the "
"available policy zones will be applied."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:197
msgid "How to use RPZ with Unbound"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:199
msgid ""
"The RPZ implementation in Unbound depends on the ``respip`` module, this "
"module needs to be loaded using :ref:`module-config:<unbound.conf.module-"
"config>`. Each policy zone is configured in Unbound using the **rpz:** "
"clause. The full documentation for RPZ in Unbound can be found in the "
":doc:`/manpages/unbound.conf`. A minimal configuration with a single "
"policy zone can look like the following, where additional elements can be"
" uncommented:"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:233
msgid ""
"In above example the policy zone will be loaded from the file "
"``rpz.nlnetlabs.nl``. An example RPZ file with all the triggers and "
"actions looks like this:"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:265
msgid ""
"It is also possible to load the zone using DNS zone transfers. Both AXFR "
"and IXFR is supported, all additions and deletion in the zone will be "
"picked up by Unbound and reflected in the local policies. Transferring "
"the policy using a DNS zone transfer is as easy as specifying the server "
"to get the zone from:"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:279
msgid ""
"The zone will now be transferred from the configured address and saved to"
" a zonefile on disk. It is possible to have more than one policy zone in "
"Unbound. Having multiple policy zones is as simple as having multiple "
"**rpz:** clauses:"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:294
msgid ""
"The policy zones will be applied in the configured order. In the example,"
" Unbound will only look at the ``rpz2.nlnetlabs.nl`` policies if there is"
" no match in the ``rpz.nlnetlabs.nl`` zone. If there is no match in any "
"of the configured zones Unbound will continue to resolve the domain by "
"sending upstream queries. Note that a PASSTHRU action is considered a "
"match, having that action in the first zone will therefore stop Unbound "
"from looking further at other policy zones."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:302
msgid ""
"Unbound has the possibility to override the actions that will be used for"
" policies in a zone that matches the zone’s triggers. This can be done "
"using the :ref:`rpz-action-override:<unbound.conf.rpz.rpz-action-"
"override>` configuration option. The possible values for the option are: "
"``nxdomain``, ``nodata``, ``passthru``, ``drop``, ``disabled``, and "
"``cname``. The first four options of this list will do the same as the "
"RPZ actions with the same name."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:311
msgid ""
"The ``cname`` override option will make it possible to apply a local data"
" action using a CNAME for all matching triggers in the policy zone. The "
"CNAME to use in the answer can be configured using the :ref:`rpz-cname-"
"override:<unbound.conf.rpz.rpz-cname-override>` configuration option. "
"Using these overrides is nice if you use an external feed to get a list "
"of triggers, but would like to redirect all your users to your own "
"domain:"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:326
msgid "This also requires a change in the Unbound configuration:"
msgstr ""

#: ../../source/topics/filtering/rpz.rst:339
msgid ""
"The ``disabled`` option will stop Unbound from applying any of the "
"actions in the zone. This, combined with the ``rpz-log`` option, is a "
"nice way to test what would happen to your traffic when a policy will be "
"enabled, without directly impacting your users. The difference between "
"``disabled`` and ``passthru`` is that disabled is not considered to be a "
"valid match and will therefore not stop Unbound from looking at the next "
"configured policy zone."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:346
msgid ""
"When :ref:`rpz-log:<unbound.conf.rpz.rpz-log>` is set to yes, Unbound "
"will log all applied actions for a policy zone. With ``rpz-log`` enabled "
"you can specify a name for the log using :ref:`rpz-log-"
"name:<unbound.conf.rpz.rpz-log-name>`, this way you can easily find all "
"matches for a specific zone. It is also possible to get statistics per "
"applied RPZ action using :ref:`unbound-control stats<unbound-"
"control.commands.stats>` or :ref:`unbound-control stats_noreset<unbound-"
"control.commands.stats_noreset>`. This requires the :ref:`extended-"
"statistics:<unbound.conf.extended-statistics>` to be enabled."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:357
msgid ""
"Unbound’s RPZ implementation works together with the tags functionality. "
"This makes it possible to enable (some of) the policy zones only for a "
"subset of users. To do this, the tags need to be defined using :ref"
":`define-tag:<unbound.conf.define-tag>`, the correct tags need to be "
"matched either with the client IP prefix using :ref:`access-control-"
"tag:<unbound.conf.access-control-tag>` or the clients on a listening "
"interface using :ref:`interface-tag:<unbound.conf.interface-tag>`, and "
"the tags need to be specified for the policy zones for which they apply."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:391
msgid ""
"Queries from 127.0.0.1 will not be filtered. For queries coming from "
"127.0.0.10 or the eth0 interface, only the policies from the "
"social.rpz.example.com zone will be used. For queries coming from "
"127.0.0.30 only the policies from the malware.rpz.example.com zone will "
"be used. Queries coming from 127.0.0.20 will be subjected to the policies"
" from both zones."
msgstr ""

#: ../../source/topics/filtering/rpz.rst:400
msgid ""
":ref:`manpages/unbound.conf:Response Policy Zone Options`, :ref:`module-"
"config<unbound.conf.module-config>`, :ref:`define-tag<unbound.conf"
".define-tag>`, :ref:`access-control-tag<unbound.conf.access-control-"
"tag>`, and :ref:`extended-statistics<unbound.conf.extended-statistics>` "
"in the :doc:`unbound.conf(5)</manpages/unbound.conf>` manpage."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:4
msgid "Tags and Views"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:6
msgid ""
"The tags and views functionality make it possible to send specific DNS "
"answers based on the IP address of the client."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:10
msgid "Tags"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:12
msgid ""
"The tags functionality makes it possible to divide incoming client "
"queries in categories (tags), and use :ref:`local-zone:<unbound.conf"
".local-zone>` and :ref:`local-data:<unbound.conf.local-data>` information"
" for these specific tags."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:16
msgid ""
"Before these tags can be used, you need to define them in the Unbound "
"configuration using :ref:`define-tag:<unbound.conf.define-tag>`. In this "
"example, a tag for domains containing malware is set, along with one for "
"domains of gambling sites:"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:26
msgid ""
"Now that Unbound is aware of the existing tags, it is possible to start "
"using them."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:29
msgid ""
"The :ref:`access-control-tag:<unbound.conf.access-control-tag>` element "
"is used to specify the tag to use for client source address. "
"Alternatively, the :ref:`interface-tag:<unbound.conf.interface-tag>` "
"element is used to specify the tag to use for clients on a specific "
"listening interface. You can add multiple tags to these elements:"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:49
msgid ""
"Any ``access-control*:`` setting overrides all ``interface-*:`` settings "
"for targeted clients."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:52
msgid ""
"Unbound will create a ``*-tag`` element with the “allow” type if the IP "
"address block / listening interface in the ``*-tag`` element does not "
"match an existing access control rule."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:56
msgid ""
"When a query comes in that is marked with a tag, Unbound starts searching"
" its local-zone tree for the best match. The best match is the most "
"specific local-zone with a matching tag, or without any tag. That means "
"that local-zones without any tag will be used for all queries and tagged "
"local-zones only for queries with matching tags."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:63
msgid ""
"Adding tags to local-zones can be done using the :ref:`local-zone-"
"tag:<unbound.conf.local-zone-tag>` element:"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:77
msgid ""
"A local-zone can have multiple tags, as illustrated in the example above."
" The tagged local-zones will be used if one or more tags match the query."
" So, the matchestwotags.example local-zone will be used for all queries "
"with at least the malware or gambling tag. The used local-zone type will "
"be the type specified in the matching local-zone. It is possible to "
"depend the local-zone type on the client and tag combination. Setting tag"
" specific local-zone types can be done using :ref:`access-control-tag-"
"action:<unbound.conf.access-control-tag-action>` and/or :ref:`interface-"
"tag-action:<unbound.conf.interface-tag-action>`:"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:97
msgid ""
"In addition to configuring a local-zone type for specific clients/tag "
"match, it is also possible to set the used local-data RRs. This can be "
"done using the :ref:`access-control-tag-data:<unbound.conf.access-"
"control-tag-data>` and/or :ref:`interface-tag-data:<unbound.conf"
".interface-tag-data>` elements:"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:111
msgid ""
"Sometimes you might want to override a local-zone type for a specific IP "
"prefix or interface, regardless the type configured for tagged and "
"untagged local zones, and regardless the type configured using :ref"
":`access-control-tag-action:<unbound.conf.access-control-tag-action>` "
"and/or :ref:`interface-tag-action:<unbound.conf.interface-tag-action>`. "
"This override can be done using :ref:`local-zone-override:<unbound.conf"
".local-zone-override>`."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:120
msgid "Views"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:122
msgid ""
"Tags make is possible to divide a large number of local-zones in "
"categories, and assign these categories to a large number of IP address "
"blocks. As tags on the clients and local-zones are stored in bitmaps, it "
"is advised to keep the number of tags low. Specifically for client "
"prefixes (i.e., ``access-control-tag*:``), if a lot of clients have their"
" own local-zones, without sharing these to other IP prefixes, it can "
"result in a large amount tags. In this situation it is more convenient to"
" give the clients' IP prefix its own tree containing local-zones. Another"
" benefit of having a separate local zone tree is that it makes it "
"possible to apply a local-zone action to a part of the domain space, "
"without having other local-zone elements of subdomains overriding this. "
"Configuring a client specific local-zone tree can be done using views."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:136
msgid ""
"A view is a named list of configuration options. The supported view "
"configuration options are :ref:`local-zone:<unbound.conf.view.local-"
"zone>` and :ref:`local-data:<unbound.conf.view.local-data>`."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:141
msgid ""
"A view is configured using a **view:** clause. There may be multiple view"
" clauses, each with a unique name. For example:"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:152
msgid ""
"Mapping a view to a client can be done using the :ref:`access-control-"
"view:<unbound.conf.access-control-view>` element:"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:159
msgid ""
"Alternatively, mapping a view to clients in a specific interface can be "
"done using the :ref:`interface-view:<unbound.conf.interface-view>` "
"element:"
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:166
msgid ""
"By default, view configuration options override the global configuration "
"outside the view. When a client matches a view it will only use the "
"view's local-zone tree. This behaviour can be changed by setting :ref"
":`view-first:<unbound.conf.view.view-first>` to yes. If view-first is "
"enabled, Unbound will try to use the view's local-zone tree, and if there"
" is no match it will search the global tree."
msgstr ""

#: ../../source/topics/filtering/tags-views.rst:175
msgid ""
":ref:`manpages/unbound.conf:View Options` in the "
":doc:`/manpages/unbound.conf` manpage."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:4
msgid "Aggressive NSEC"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:6
msgid ""
"Unbound has implemented the aggressive use of the DNSSEC-Validated cache,"
" also known as *Aggressive NSEC*, based on :rfc:`8198`. This section "
"first describes how NSEC works, and then covers how synthesised answers "
"can be generated based on the DNSSEC-Validated cache."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:14
msgid ""
"DNS relies heavily on caching. A lot of performance can be gained by "
"storing answers to previous queries close to the client. If an "
"authoritative name server would have to be queried for every single "
"request, performance would be severely impacted."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:19
msgid ""
"In addition to caching the positive answer to queries, negative answers "
"are also cached. These negative answers are an acknowledgement from the "
"name server that a name does not exist (an answer with the response code "
"set to NXDOMAIN) or that the type in the query does not exist for the "
"name in the query. The latter is known as an answer with the NODATA "
"pseudo response code, as specified in :rfc:`2308#section-1`."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:29
msgid "NSEC (Next Secure) Records"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:31
msgid ""
"DNSSEC is not only used to prove the authenticity of records in a DNS "
"answer by verifying the DNSSEC signatures of the records, it is also used"
" to prove the absence of records. DNSSEC uses NSEC (next secure), as well"
" as NSEC3 records for these proof of non-existence answers. An NSEC "
"record indicates that there are no records that are sorted between the "
"two domain names it contains. The canonical DNS name order is used for "
"the sorting, as described in :rfc:`4034#section-6.1`. An NSEC record also"
" has a type bitmap which specifies the record types that exist for the "
"owner name of the NSEC record. Like any other DNS record, the "
"authenticity of NSEC records can be validated using its DNSSEC signature "
"which is located in the RRSIG record."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:41
msgid "This NSEC record is taken as an example:"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:47
msgid ""
"The record indicates that the owner name ``golf.example.net`` exists and "
"that the owner name has records for the *TXT*, *RRSIG* and *NSEC* types. "
"It therefore proves that there is no *A* record for ``golf.example.net``."
" This NSEC record also proves that there are no records alphabetically "
"sorted between its owner and its next domain name (kilo.example.net). "
"This record therefore proves that there is no record for "
"juliett.example.net."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:55
msgid "DNSSEC Signatures on Wildcard Records"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:57
msgid ""
"Wildcard expansion on NSEC record is specifically allowed by :rfc:`4592`."
" In order to answer a DNS query using a wildcard record, an authoritative"
" nameserver replaces the owner name of the wildcard record with the name "
"in the query. DNSSEC is designed in such way that it can sign a complete "
"zone before it starts serving. Because the query name that will be used "
"for the wildcard record is not known when the zone is being signed, it is"
" not possible to make a DNSSEC signature for it. Therefore the original "
"owner name with the wildcard label is used for the signature."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:66
msgid ""
"The labels field that is part of the RRSIG record indicates the number of"
" labels of the owner name without the wildcard label. This labels field "
"can be used by a DNSSEC validator to detect that this is a signature for "
"a wildcard record. A DNSSEC validator then knows it needs to validate the"
" signature using the original wildcard owner, and not the expanded owner "
"that matches the query name. A validator gets the original owner name by "
"taking the number of rightmost labels defined in the labels field from "
"the expanded owner and then prepend it with the wildcard label ``*``."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:75
msgid ""
"This is an example of a wildcard expanded RRSIG record, with the "
"signature omitted to keep the text compact:"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:82
msgid ""
"This RRSIG record has a label count of two, while the number of labels in"
" the owner name (excluding the root label) is three. Using that "
"information a validator will take the two last labels of the owner name "
"(example.net) and prepend the wildcard label to it. It therefore checks "
"the signature using the original wildcard name, which is "
"``*.example.net``."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:89
msgid "Generating NODATA Answers"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:91
msgid ""
"The traditional Unbound cache implementation is based on exactly matching"
" cached messages to the query name, query type and query class. If a "
"client asks for a *TXT* record for ``example.net``, the resolver will "
"search the cache and if that fails go and look up the answer at the "
"authoritative name server. This query to the authoritative name server "
"will result in a response containing the existing *TXT* record. If the "
"resolver now receives a query for the same name but for the *TLSA* type, "
"the resolver will check its cache, in this case can not find a matching "
"record in the cache and will, as a result, send a query to the "
"authoritative name server. That name server will now reply with a NODATA "
"answer, indicating that the ``example.net`` name does exist, but there is"
" no record for that name with the TLSA record. A third query for the same"
" name for another non-existing type, for example *SRV*, will once again "
"not result in a cache hit and will generate yet another query with again "
"a NODATA answer as result."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:105
msgid ""
"In this example the ``example.net`` zone is DNSSEC signed. This means the"
" absence of these records need to be proven using NSEC records. NSEC "
"records indicate which types exist for a name and which names exist in a "
"zone. NSEC records have a cryptographic signature which make them tamper "
"proof. By knowing the existing record and types in a zone, a DNSSEC "
"validator can prove that the combination of query name and query type "
"indeed does not exist."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:112
msgid ""
"The NODATA answer for the ``example.net`` name with the *TLSA* query type"
" could for example contain this NSEC record:"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:119
msgid ""
"This record proves which types exist for ``example.net`` (*A, NS, SOA* "
"etc.) and thereby proves that the *TLSA* record indeed does not exist. "
"The NODATA response to the third query in above example (the *SRV* query "
"for ``example.net``) will contain exactly the same NSEC record to prove "
"the absence of the *SRV* record. Because this NSEC record was already "
"cached after the lookup for the TLSA record we could have used that "
"already obtained NSEC record to generate a DNSSEC secure answer, without "
"the need to send another query to the authoritative name server."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:129
msgid ""
"To use previously cached NSEC records to generate responses in Unbound, "
"use the :ref:`aggressive-nsec<unbound.conf.aggressive-nsec>` option in "
"the configuration file:"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:139
msgid "Generating NXDOMAIN Answers"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:141
msgid ""
"An answer with the NXDOMAIN response code indicates that a name does not "
"exist at all, which is also proven using an NSEC record. If "
"``example.net`` would contain these alphabetically sorted records (some "
"simplification ahead):"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:152
msgid "then DNSSEC would make sure these NSEC records are inserted and signed:"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:160
msgid ""
"They attest that no name exists between ``alfa.example.net`` and "
"``sierra.example.net``. So if you query for ``lima.example.net``, you "
"will get back the NXDOMAIN from the authoritative name server, as well as"
" the NSEC record for ``alfa.example.net`` — ``sierra.example.net`` as "
"proof that the query name does not exist and the NSEC record for "
"``example.net`` — ``alfa.example.net`` as proof that the "
"``*.example.net`` wildcard record does not exist."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:168
msgid ""
"If the user now queries for for ``delta.example.net``, resolvers would "
"normally ask the authoritative server again because there is no message "
"cached for that name. But because the NSEC records for "
"``alfa.example.net`` — ``sierra.example.net`` and ``example.net`` — "
"``alfa.example.net`` are already cached, the implementation of "
":rfc:`8198` will allow Unbound to deduce that it doesn't need to send a "
"new query. It is already able to prove that the name doesn't exist and "
"immediately, or *aggressively* if you will, returns an NXDOMAIN answer."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:178
msgid "Generating Wildcard Answers"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:180
msgid ""
"There is one more type of message that can be generated using cached NSEC"
" records, namely wildcard answers. A DNSSEC validator only accepts a "
"wildcard answer when there is proof that there is no record for the query"
" name. When we have this zone containing a wildcard record:"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:193
msgid ""
"then a TXT query for ``delta.example.net`` will be answered with the "
"following records, indicating that there is no direct match for the query"
" name but that there is a matching wildcard record:"
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:207
msgid ""
"The ``alfa.example.net`` — ``sierra.example.net`` NSEC record indicates "
"that there is no ``delta.example.net`` record. The labels field in the "
"signature indicates that the returned TXT record is expanded using the "
"``*.example.net`` record."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:212
msgid ""
"Unbound uses this knowledge to store the wildcard RRset also under the "
"original owner name, containing the wildcard record, when aggressive use "
"of NSEC is enabled. After receiving a query for ``echo.example.net``, "
"Unbound finds the NSEC record proving the absence in its cache. Unbound "
"will then look in the cache for a ``*.example.net`` *TXT* record, which "
"also exists. These records are then used to generate an answer without "
"sending a query to the name server."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:220
msgid ""
"Aggressive NSEC can result in a reduction of traffic on all levels of the"
" DNS hierarchy but it will be most noticeable at the root, as typically "
"more than half of all responses are NXDOMAIN."
msgstr ""

#: ../../source/topics/privacy/aggressive-nsec.rst:224
msgid ""
"Another benefit of a wide deployment of aggressive NSEC is the incentive "
"to DNSSEC sign your zone. If you don’t want to have a large amount of "
"queries for non-existing records at your name server, signing your zone "
"will prevent this."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:4
msgid "DNS-over-HTTPS"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:6
msgid ""
"DNS-over-TLS (DoT) makes it possible to encrypt DNS messages and gives a "
"DNS client the possibility to authenticate a resolver. As implied by the "
"name, this is done by sending DNS messages over TLS. Unbound can handle "
"TLS encrypted DNS messages since `2011 "
"<https://github.com/NLnetLabs/unbound/commit/aa0536dcb5846206d016a03d8d66ad4279247d9e>`__,"
" long before the IETF DPRIVE working group started its work on the `DoT "
"specification <https://tools.ietf.org/html/rfc7858>`__."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:14
msgid ""
"There are, however, DNS clients that do not support DoT but are able to "
"use DNS-over-HTTPS (DoH) instead. Where DoT sends a DNS message directly "
"over TLS, DoH has an HTTP layer in between. Where DoT uses its own TCP "
"port (853), DoH uses the standard HTTPS port (443)."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:19
msgid ""
"By adding downstream DoH support to Unbound we hope to increase the ratio"
" of encrypted DNS traffic and increase the number of resolvers that offer"
" encrypted services in home networks, enterprise networks, ISPs, and "
"public resolvers."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:24
msgid "Implementation Details"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:26
msgid ""
"The DoH implementation in Unbound requires TLS, and only works over "
"HTTP/2. The query pipelining and out-of-order processing functionality "
"that is provided by HTTP/2 streams is needed to be able to provide "
"performance that is on par with DoT. The HTTP/2 capability is negotiated "
"using Application-Layer Protocol Negotiation (ALPN) TLS extension, which "
"is supported in OpenSSL from version 1.0.2 onward."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:33
msgid ""
"Unbound uses the `nghttp2 <https://nghttp2.org/>`__ library to handle the"
" HTTP/2 framing layer. This library does not take care of any I/O "
"handling, which makes it possible to easily integrate it in the existing "
"Unbound event loop and TCP handling. Adding HTTP/2 on top of the existing"
" TCP code makes it possible to also use the existing TCP configuration "
"options for the DoH connections. These existing options include the "
"number of allowed incoming TCP connections, the TCP timeout settings, and"
" the limits on TCP connections per client IP address or netblock."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:42
msgid ""
"The use of HTTP makes it possible to change the DNS message format by "
"using new media types. Unbound currently only supports the ``application"
"/dns-message`` media type, as this is the only format standardised in the"
" IETF standards track, and the only supported format by popular DNS "
"clients. We are keeping an eye on the new possibilities here, such as "
"using the ``application/oblivious-dns-message`` media type."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:50
msgid ""
"The use of the HTTP layer also makes it possible to return more detailed "
"information to a client in case of malformed requests. This can be done "
"by using a non-successful HTTP status code, or by closing an individual "
"stream by sending an RST_STREAM frame. The HTTP status codes that can be "
"returned by Unbound are:"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:57
msgid "200 OK"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:56
msgid ""
"Unbound is able to process the query, and return an answer. This could be"
" a negative answer or an error like SERVFAIL or FORMERR."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:61
msgid "404 Not Found"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:60
msgid ""
"The request is directed to a path other than the configured endpoint in "
"http-endpoint (default ``/dns-query``)."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:72
msgid "413 Payload Too Large"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:64
msgid ""
"The payload received in the POST request is too large. Payloads cannot be"
" larger than the content-length communicated in the request header. The "
"payload length is limited to 512 bytes if :ref:`harden-large-"
"queries:<unbound.conf.harden-large-queries>` is enabled, and otherwise "
"limited to the value configured in :ref:`msg-buffer-size:<unbound.conf"
".msg-buffer-size>` (default 65552 bytes). To prevent the allocation of "
"overly large buffers, the maximum size is limited to the size of the "
"first DATA frame if no content-length is received in the request."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:79
msgid "414 URI Too Long"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:75
msgid ""
"The base64url encoded DNS query in the GET request is too large. The DNS "
"query length is limited to 512 bytes if :ref:`harden-large-"
"queries:<unbound.conf.harden-large-queries>` is enabled, and limited to "
":ref:`msg-buffer-size:<unbound.conf.msg-buffer-size>` otherwise."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:85
msgid "415 Unsupported Media Type"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:82
msgid ""
"The media type of the request is not supported. This happens if the "
"request contains a content-type header that is set to anything but "
"``application/dns-message``. Requests without content-type will be "
"treated as ``application/dns-message``."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:89
msgid "400 Bad Request"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:88
msgid "No valid query received, not matched by any of the above 4xx status codes."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:92
msgid "501 Not Implemented"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:92
msgid "The method used in the request is not GET or POST."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:95
msgid "Using DoH"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:97
msgid ""
"As mentioned above, the `nghttp2 <https://nghttp2.org/>`__ library is "
"required to use Unbound’s DoH functionality. Compiling and installing "
"Unbound with libnghttp2 can be done using:"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:106
msgid ""
"Enabling DoH in Unbound is as simple as configuring the TLS certificate "
"and the corresponding private key that will be used for the connection, "
"and configuring Unbound to listen on the HTTPS port:"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:117
msgid ""
"The port that Unbound will use for incoming DoH traffic is by default set"
" to 443 and can be changed using the :ref:`https-port:<unbound.conf"
".https-port>` configuration option."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:121
msgid ""
"``dohclient``, an Unbound test utility which can be built with ``make "
"dohclient`` in Unbound's source tree, shows that Unbound is now ready to "
"handle DoH queries on the default HTTP endpoint, which is ``/dns-query``:"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:151
msgid ""
"Queries to other paths will be answered with a ``404`` status code. The "
"endpoint can be changed using the :ref:`http-endpoint:<unbound.conf.http-"
"endpoint>` configuration option."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:155
msgid ""
"The maximum number of concurrent HTTP/2 streams can be configured using "
"the :ref:`http-max-streams:<unbound.conf.http-max-streams>` configuration"
" option. The default for this option is 100, as per HTTP/2 RFC "
"recommended minimum. This value will be in the ``SETTINGS`` frame sent to"
" the client, and enforced by Unbound."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:161
msgid ""
"Because requests can be spread out over multiple HTTP/2 frames, which can"
" be interleaved between frames of different streams, we have to create "
"buffers containing partial queries. A new counter is added to Unbound to "
"limit the total memory consumed by all query buffers. The limit can be "
"configured using the :ref:`http-query-buffer-size:<unbound.conf.http-"
"query-buffer-size>` option. New streams will be closed by sending an "
"``RST_STREAM`` frame when this limit is exceeded."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:169
msgid ""
"After Unbound is done resolving a request the DNS response will be stored"
" in a buffer, waiting until Unbound is ready to sent them back to the "
"client using HTTP. These buffers also have a maximum amount of memory "
"they are allowed to consume. This maximum is configurable using the :ref"
":`http-response-buffer-size:<unbound.conf.http-response-buffer-size>` "
"configuration option."
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:177
msgid "Metrics"
msgstr ""

#: ../../source/topics/privacy/dns-over-https.rst:179
msgid ""
"Three DoH related metrics are available in Unbound; :ref:`num.query.https"
"<unbound-control.stats.num.query.https>` counts the number of queries "
"that have been serviced using DoH. The :ref:`mem.http.query_buffer"
"<unbound-control.stats.mem.http.query_buffer>`, and "
":ref:`mem.http.response_buffer<unbound-"
"control.stats.mem.http.response_buffer>` counters keep track of the "
"memory used for the DoH query and response buffers."
msgstr ""

