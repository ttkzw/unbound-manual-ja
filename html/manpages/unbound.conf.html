<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>unbound.conf(5) &mdash; Unbound 1.19.0 ドキュメント</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/dark.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/light.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="unbound-host(1)" href="unbound-host.html" />
    <link rel="prev" title="unbound-checkconf(8)" href="unbound-checkconf.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/unbound-duotone-white.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.19.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/configuration.html">Configuration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Use Cases</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../use-cases/home-resolver.html">Resolver for Home Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use-cases/local-stub.html">Local DNS (Stub) Resolver for a Single Machine</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Core</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topics/core/proxy.html">Downstream Proxy Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topics/core/serve-stale.html">Serving Stale Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topics/core/performance.html">Performance Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topics/core/monitoring.html">Monitoring and Reporting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Privacy</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topics/privacy/aggressive-nsec.html">Aggressive NSEC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topics/privacy/dns-over-https.html">DNS-over-HTTPS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Filtering</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topics/filtering/tags-views.html">Tags and Views</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topics/filtering/rpz.html">Response Policy Zones</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developer/libunbound-tutorial/index.html">Unbound Library Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/python-modules.html">Unbound for Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/doxygen-docs.html">Source Code Docs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Manual Pages</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="unbound.html">unbound(8)</a></li>
<li class="toctree-l1"><a class="reference internal" href="unbound-checkconf.html">unbound-checkconf(8)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">unbound.conf(5)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#synopsis">概要</a></li>
<li class="toctree-l2"><a class="reference internal" href="#description">説明</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#file-format">File Format</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#server-options">Server Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#remote-control-options">Remote Control Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stub-zone-options">Stub Zone Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#forward-zone-options">Forward Zone Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#authority-zone-options">Authority Zone Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#view-options">View Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python-module-options">Python Module Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dynamic-library-module-options">Dynamic Library Module Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dns64-module-options">DNS64 Module Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nat64-operation">NAT64 Operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dnscrypt-options">DNSCrypt Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edns-client-subnet-module-options">EDNS Client Subnet Module Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#opportunistic-ipsec-support-module-options">Opportunistic IPsec Support Module Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cache-db-module-options">Cache DB Module Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dnstap-logging-options">DNSTAP Logging Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#response-policy-zone-options">Response Policy Zone Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-control-example">Memory Control Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#files">Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#see-also">See Also</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="unbound-host.html">unbound-host(1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="libunbound.html">libunbound(3)</a></li>
<li class="toctree-l1"><a class="reference internal" href="unbound-control.html">unbound-control(8)</a></li>
<li class="toctree-l1"><a class="reference internal" href="unbound-anchor.html">unbound-anchor(8)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference/rfc-compliance.html">RFC Compliance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/history/index.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/todo.html">Docs To-Do List</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Unbound</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">unbound.conf(5)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/manpages/unbound.conf.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="unbound-conf-5">
<h1>unbound.conf(5)<a class="headerlink" href="#unbound-conf-5" title="この見出しへのパーマリンク">¶</a></h1>
<section id="synopsis">
<h2>概要<a class="headerlink" href="#synopsis" title="この見出しへのパーマリンク">¶</a></h2>
<p><strong>unbound.conf</strong></p>
</section>
<section id="description">
<h2>説明<a class="headerlink" href="#description" title="この見出しへのパーマリンク">¶</a></h2>
<p><strong>unbound.conf</strong> is used to configure <a class="reference internal" href="unbound.html"><span class="doc">unbound(8)</span></a>.
The file format has attributes and values.
Some attributes have attributes inside them.
The notation is: <code class="docutils literal notranslate"><span class="pre">attribute:</span> <span class="pre">value</span></code>.</p>
<p>Comments start with <code class="docutils literal notranslate"><span class="pre">#</span></code> and last to the end of line.
Empty lines are ignored as is whitespace at the beginning of a line.</p>
<p>The utility <a class="reference internal" href="unbound-checkconf.html"><span class="doc">unbound-checkconf(8)</span></a> can be
used to check <code class="docutils literal notranslate"><span class="pre">unbound.conf</span></code> prior to usage.</p>
</section>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="この見出しへのパーマリンク">¶</a></h2>
<p>An example config file is shown below.
Copy this to <code class="file docutils literal notranslate"><span class="pre">/etc/unbound/unbound.conf</span></code> and start the server with:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ unbound -c /etc/unbound/unbound.conf
</pre></div>
</div>
<p>Most settings are the defaults.
Stop the server with:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ kill `cat /etc/unbound/unbound.pid`
</pre></div>
</div>
<p>Below is a minimal config file.
The source distribution contains an extensive <code class="file docutils literal notranslate"><span class="pre">example.conf</span></code> file with
all the options.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># unbound.conf(5) config file for unbound(8).
server:
directory: &quot;/etc/unbound&quot;
username: unbound
# make sure unbound can access entropy from inside the chroot.
# e.g. on linux the use these commands (on BSD, devfs(8) is used):
#      mount --bind -n /dev/urandom /etc/unbound/dev/urandom
# and  mount --bind -n /dev/log /etc/unbound/dev/log
chroot: &quot;/etc/unbound&quot;
# logfile: &quot;/etc/unbound/unbound.log&quot;  #uncomment to use logfile.
pidfile: &quot;/etc/unbound/unbound.pid&quot;
# verbosity: 1      # uncomment and increase to get more logging.
# listen on all interfaces, answer queries from the local subnet.
interface: 0.0.0.0
interface: ::0
access-control: 10.0.0.0/8 allow
access-control: 2001:DB8::/64 allow
</pre></div>
</div>
</section>
<section id="file-format">
<h2>File Format<a class="headerlink" href="#file-format" title="この見出しへのパーマリンク">¶</a></h2>
<p>There must be whitespace between keywords.
Attribute keywords end with a colon <code class="docutils literal notranslate"><span class="pre">':'</span></code>.
An attribute is followed by a value, or its containing attributes in which case
it is referred to as a clause.
Clauses can be repeated throughout the file (or included files) to group
attributes under the same clause.</p>
<p id="unbound-conf-include">Files can be included using the <strong>include:</strong> directive.
It can appear anywhere, it accepts a single file name as argument.
Processing continues as if the text from the included file was copied into the
config file at that point.
If also using <a class="reference internal" href="#unbound-conf-chroot"><span class="std std-ref">chroot:</span></a>, using full path names for
the included files works, relative pathnames for the included names work if the
directory where the daemon is started equals its chroot/working directory or is
specified before the include statement with <a class="reference internal" href="#unbound-conf-directory"><span class="std std-ref">directory:
dir</span></a>.
Wildcards can be used to include multiple files, see <em>glob(7)</em>.</p>
<p id="unbound-conf-include-toplevel">For a more structural include option, the <strong>include-toplevel:</strong> directive can
be used.
This closes whatever clause is currently active (if any) and forces the use of
clauses in the included files and right after this directive.</p>
<section id="server-options">
<span id="unbound-conf-server"></span><h3>Server Options<a class="headerlink" href="#server-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>These options are part of the <strong>server:</strong> clause.</p>
<dl id="unbound-conf-verbosity">
<dt>verbosity: <em>&lt;number&gt;</em></dt><dd><p>The verbosity level.</p>
<dl class="simple">
<dt>Level 0</dt><dd><p>No verbosity, only errors.</p>
</dd>
<dt>Level 1</dt><dd><p>Gives operational information.</p>
</dd>
<dt>Level 2</dt><dd><p>Gives detailed operational information including short information per
query.</p>
</dd>
<dt>Level 3</dt><dd><p>Gives query level information, output per query.</p>
</dd>
<dt>Level 4</dt><dd><p>Gives algorithm level information.</p>
</dd>
<dt>Level 5</dt><dd><p>Logs client identification for cache misses.</p>
</dd>
</dl>
<p>The verbosity can also be increased from the command line and during run
time via remote control. See <a class="reference internal" href="unbound.html"><span class="doc">unbound(8)</span></a> and
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a> respectively.</p>
<p>Default: 1</p>
</dd>
</dl>
<dl id="unbound-conf-statistics-interval">
<dt>statistics-interval: <em>&lt;seconds&gt;</em></dt><dd><p>The number of seconds between printing statistics to the log for every
thread.
Disable with value <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>.
The histogram statistics are only printed if replies were sent during the
statistics interval, requestlist statistics are printed for every interval
(but can be 0).
This is because the median calculation requires data to be present.</p>
<p>Default: 0 (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-statistics-cumulative">
<dt>statistics-cumulative: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, statistics are cumulative since starting Unbound, without
clearing the statistics counters after logging the statistics.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-extended-statistics">
<dt>extended-statistics: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, extended statistics are printed from
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a>.
The counters are listed in
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a>.
Keeping track of more statistics takes time.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-statistics-inhibit-zero">
<dt>statistics-inhibit-zero: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, selected extended statistics with a value of 0 are inhibited
from printing with
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a>.
These are query types, query classes, query opcodes, answer rcodes
(except NOERROR, FORMERR, SERVFAIL, NXDOMAIN, NOTIMPL, REFUSED)
and PRZ actions.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-num-threads">
<dt>num-threads: <em>&lt;number&gt;</em></dt><dd><p>The number of threads to create to serve clients. Use 1 for no threading.</p>
<p>Default: 1</p>
</dd>
</dl>
<dl id="unbound-conf-port">
<dt>port: <em>&lt;port number&gt;</em></dt><dd><p>The port number on which the server responds to queries.</p>
<p>Default: 53</p>
</dd>
</dl>
<dl id="unbound-conf-interface">
<dt>interface: <em>&lt;IP address or interface name[&#64;port]&gt;</em></dt><dd><p>Interface to use to connect to the network.
This interface is listened to for queries from clients, and answers to
clients are given from it.
Can be given multiple times to work on several interfaces.
If none are given the default is to listen on localhost.</p>
<p>If an interface name is used instead of an IP address, the list of IP
addresses on that interface are used.
The interfaces are not changed on a reload (<code class="docutils literal notranslate"><span class="pre">kill</span> <span class="pre">-HUP</span></code>) but only on
restart.</p>
<p>A port number can be specified with &#64;port (without spaces between interface
and port number), if not specified the default port (from
<a class="reference internal" href="#unbound-conf-port"><span class="std std-ref">port:</span></a>) is used.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ip-address">
<dt>ip-address: <em>&lt;IP address or interface name[&#64;port]&gt;</em></dt><dd><p>Same as <a class="reference internal" href="#unbound-conf-interface"><span class="std std-ref">interface:</span></a> (for ease of
compatibility with <a class="reference external" href="https://nsd.docs.nlnetlabs.nl/en/latest/manpages/nsd.conf.html" title="(in NSD v4.3.9)"><span>nsd.conf(5)</span></a>).</p>
</dd>
</dl>
<dl id="unbound-conf-interface-automatic">
<dt>interface-automatic: <em>&lt;yes or no&gt;</em></dt><dd><p>Listen on all addresses on all (current and future) interfaces, detect the
source interface on UDP queries and copy them to replies.
This is a lot like <a class="reference internal" href="#unbound-conf-ip-transparent"><span class="std std-ref">ip-transparent:</span></a>, but
this option services all interfaces whilst with
<a class="reference internal" href="#unbound-conf-ip-transparent"><span class="std std-ref">ip-transparent:</span></a> you can select which
(future) interfaces Unbound provides service on.
This feature is experimental, and needs support in your OS for particular
socket options.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-interface-automatic-ports">
<dt>interface-automatic-ports: <em>&quot;&lt;string&gt;&quot;</em></dt><dd><p>List the port numbers that
<a class="reference internal" href="#unbound-conf-interface-automatic"><span class="std std-ref">interface-automatic:</span></a> listens on.
If empty, the default port is listened on.
The port numbers are separated by spaces in the string.</p>
<p>This can be used to have interface automatic to deal with the interface,
and listen on the normal port number, by including it in the list, and
also HTTPS or DNS-over-TLS port numbers by putting them in the list as
well.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-outgoing-interface">
<dt>outgoing-interface: <em>&lt;IPv4/IPv6 address or IPv6 netblock&gt;</em></dt><dd><p>Interface to use to connect to the network.
This interface is used to send queries to authoritative servers and receive
their replies.
Can be given multiple times to work on several interfaces.
If none are given the default (all) is used.
You can specify the same interfaces in
<a class="reference internal" href="#unbound-conf-interface"><span class="std std-ref">interface:</span></a> and
<a class="reference internal" href="#unbound-conf-outgoing-interface"><span class="std std-ref">outgoing-interface:</span></a> lines, the
interfaces are then used for both purposes.
Outgoing queries are sent via a random outgoing interface to counter
spoofing.</p>
<p>If an IPv6 netblock is specified instead of an individual IPv6 address,
outgoing UDP queries will use a randomised source address taken from the
netblock to counter spoofing.
Requires the IPv6 netblock to be routed to the host running Unbound, and
requires OS support for unprivileged non-local binds (currently only
supported on Linux).
Several netblocks may be specified with multiple
<a class="reference internal" href="#unbound-conf-outgoing-interface"><span class="std std-ref">outgoing-interface:</span></a> options, but do
not specify both an individual IPv6 address and an IPv6 netblock, or the
randomisation will be compromised.
Consider combining with <a class="reference internal" href="#unbound-conf-prefer-ip6"><span class="std std-ref">prefer-ip6:</span></a> yes to
increase the likelihood of IPv6 nameservers being selected for queries.
On Linux you need these two commands to be able to use the freebind socket
option to receive traffic for the ip6 netblock:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ip -6 addr add mynetblock/64 dev lo &amp;&amp; \
ip -6 route add local mynetblock/64 dev lo
</pre></div>
</div>
</dd>
</dl>
<dl id="unbound-conf-outgoing-range">
<dt>outgoing-range: <em>&lt;number&gt;</em></dt><dd><p>Number of ports to open.
This number of file descriptors can be opened per thread.
Must be at least 1.
Default depends on compile options.
Larger numbers need extra resources from the operating system.
For performance a very large value is best, use libevent to make this
possible.</p>
<p>Default: 4096 (libevent) / 960 (minievent) / 48 (windows)</p>
</dd>
</dl>
<dl id="unbound-conf-outgoing-port-permit">
<dt>outgoing-port-permit: <em>&lt;port number or range&gt;</em></dt><dd><p>Permit Unbound to open this port or range of ports for use to send queries.
A larger number of permitted outgoing ports increases resilience against
spoofing attempts.
Make sure these ports are not needed by other daemons.
By default only ports above 1024 that have not been assigned by IANA are
used.
Give a port number or a range of the form &quot;low-high&quot;, without spaces.</p>
<p>The <a class="reference internal" href="#unbound-conf-outgoing-port-permit"><span class="std std-ref">outgoing-port-permit:</span></a> and
<a class="reference internal" href="#unbound-conf-outgoing-port-avoid"><span class="std std-ref">outgoing-port-avoid:</span></a> statements
are processed in the line order of the config file, adding the permitted
ports and subtracting the avoided ports from the set of allowed ports.
The processing starts with the non IANA allocated ports above 1024 in the
set of allowed ports.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-outgoing-port-avoid">
<dt>outgoing-port-avoid: <em>&lt;port number or range&gt;</em></dt><dd><p>Do not permit Unbound to open this port or range of ports for use to send
queries.
Use this to make sure Unbound does not grab a port that another daemon
needs.
The port is avoided on all outgoing interfaces, both IPv4 and IPv6.
By default only ports above 1024 that have not been assigned by IANA are
used.
Give a port number or a range of the form &quot;low-high&quot;, without spaces.</p>
</dd>
</dl>
<dl id="unbound-conf-outgoing-num-tcp">
<dt>outgoing-num-tcp: <em>&lt;number&gt;</em></dt><dd><p>Number of outgoing TCP buffers to allocate per thread.
If set to 0, or if <a class="reference internal" href="#unbound-conf-do-tcp"><span class="std std-ref">do-tcp: no</span></a>, no TCP queries
to authoritative servers are done.
For larger installations increasing this value is a good idea.</p>
<p>Default: 10</p>
</dd>
</dl>
<dl id="unbound-conf-incoming-num-tcp">
<dt>incoming-num-tcp: <em>&lt;number&gt;</em></dt><dd><p>Number of incoming TCP buffers to allocate per thread.
If set to 0, or if <a class="reference internal" href="#unbound-conf-do-tcp"><span class="std std-ref">do-tcp: no</span></a>, no TCP queries
from clients are accepted.
For larger installations increasing this value is a good idea.</p>
<p>Default: 10</p>
</dd>
</dl>
<dl id="unbound-conf-edns-buffer-size">
<dt>edns-buffer-size: <em>&lt;number&gt;</em></dt><dd><p>Number of bytes size to advertise as the EDNS reassembly buffer size.
This is the value put into datagrams over UDP towards peers.
The actual buffer size is determined by
<a class="reference internal" href="#unbound-conf-msg-buffer-size"><span class="std std-ref">msg-buffer-size:</span></a> (both for TCP and
UDP).
Do not set higher than that value.
Setting to 512 bypasses even the most stringent path MTU problems, but is
seen as extreme, since the amount of TCP fallback generated is excessive
(probably also for this resolver, consider tuning
<a class="reference internal" href="#unbound-conf-outgoing-num-tcp"><span class="std std-ref">outgoing-num-tcp:</span></a>).</p>
<p>Default: 1232 (<a class="reference external" href="https://dnsflagday.net/2020/">DNS Flag Day 2020 recommendation</a>)</p>
</dd>
</dl>
<dl id="unbound-conf-max-udp-size">
<dt>max-udp-size: <em>&lt;number&gt;</em></dt><dd><p>Maximum UDP response size (not applied to TCP response).
65536 disables the UDP response size maximum, and uses the choice from the
client, always.
Suggested values are 512 to 4096.</p>
<p>Default: 1232 (same as <a class="reference internal" href="#unbound-conf-edns-buffer-size"><span class="std std-ref">edns-buffer-size:</span></a>)</p>
</dd>
</dl>
<dl id="unbound-conf-stream-wait-size">
<dt>stream-wait-size: <em>&lt;number&gt;</em></dt><dd><p>Number of bytes size maximum to use for waiting stream buffers.
A plain number is in bytes, append 'k', 'm' or 'g' for kilobytes, megabytes
or gigabytes (1024*1024 bytes in a megabyte).
As TCP and TLS streams queue up multiple results, the amount of memory used
for these buffers does not exceed this number, otherwise the responses are
dropped.
This manages the total memory usage of the server (under heavy use), the
number of requests that can be queued up per connection is also limited,
with further requests waiting in TCP buffers.</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-msg-buffer-size">
<dt>msg-buffer-size: <em>&lt;number&gt;</em></dt><dd><p>Number of bytes size of the message buffers.
Default is 65552 bytes, enough for 64 Kb packets, the maximum DNS message
size.
No message larger than this can be sent or received.
Can be reduced to use less memory, but some requests for DNS data, such as
for huge resource records, will result in a SERVFAIL reply to the client.</p>
<p>Default: 65552</p>
</dd>
</dl>
<dl id="unbound-conf-msg-cache-size">
<dt>msg-cache-size: <em>&lt;number&gt;</em></dt><dd><p>Number of bytes size of the message cache.
A plain number is in bytes, append 'k', 'm' or 'g' for kilobytes, megabytes
or gigabytes (1024*1024 bytes in a megabyte).</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-msg-cache-slabs">
<dt>msg-cache-slabs: <em>&lt;number&gt;</em></dt><dd><p>Number of slabs in the message cache.
Slabs reduce lock contention by threads.
Must be set to a power of 2.
Setting (close) to the number of cpus is a reasonable guess.</p>
<p>Default: 4</p>
</dd>
</dl>
<dl id="unbound-conf-num-queries-per-thread">
<dt>num-queries-per-thread: <em>&lt;number&gt;</em></dt><dd><p>The number of queries that every thread will service simultaneously.
If more queries arrive that need servicing, and no queries can be jostled
out (see <a class="reference internal" href="#unbound-conf-jostle-timeout"><span class="std std-ref">jostle-timeout:</span></a>), then the
queries are dropped.
This forces the client to resend after a timeout; allowing the server time
to work on the existing queries.
Default depends on compile options.</p>
<p>Default: 1024 (libevent) / 512 (minievent) / 24 (windows)</p>
</dd>
</dl>
<dl id="unbound-conf-jostle-timeout">
<dt>jostle-timeout: <em>&lt;msec&gt;</em></dt><dd><p>Timeout used when the server is very busy.
Set to a value that usually results in one roundtrip to the authority
servers.</p>
<p>If too many queries arrive, then 50% of the queries are allowed to run to
completion, and the other 50% are replaced with the new incoming query if
they have already spent more than their allowed time.
This protects against denial of service by slow queries or high query
rates.</p>
<p>The effect is that the qps for long-lasting queries is about
(numqueriesperthread / 2) / (average time for such long queries) qps.
The qps for short queries can be about (numqueriesperthread / 2) /
(jostletimeout in whole seconds) qps per thread, about (1024/2)*5 = 2560
qps by default.</p>
<p>Default: 200</p>
</dd>
</dl>
<dl id="unbound-conf-delay-close">
<dt>delay-close: <em>&lt;msec&gt;</em></dt><dd><p>Extra delay for timeouted UDP ports before they are closed, in msec.
This prevents very delayed answer packets from the upstream (recursive)
servers from bouncing against closed ports and setting off all sort of
close-port counters, with eg. 1500 msec.
When timeouts happen you need extra sockets, it checks the ID and remote IP
of packets, and unwanted packets are added to the unwanted packet counter.</p>
<p>Default: 0 (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-udp-connect">
<dt>udp-connect: <em>&lt;yes or no&gt;</em></dt><dd><p>Perform <em>connect(2)</em> for UDP sockets that mitigates ICMP side channel
leakage.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-unknown-server-time-limit">
<dt>unknown-server-time-limit: <em>&lt;msec&gt;</em></dt><dd><p>The wait time in msec for waiting for an unknown server to reply.
Increase this if you are behind a slow satellite link, to eg. 1128.
That would then avoid re-querying every initial query because it times out.</p>
<p>Default: 376</p>
</dd>
</dl>
<dl id="unbound-conf-so-rcvbuf">
<dt>so-rcvbuf: <em>&lt;number&gt;</em></dt><dd><p>If not 0, then set the SO_RCVBUF socket option to get more buffer space on
UDP port 53 incoming queries.
So that short spikes on busy servers do not drop packets (see counter in
<code class="docutils literal notranslate"><span class="pre">netstat</span> <span class="pre">-su</span></code>).
Otherwise, the number of bytes to ask for, try &quot;4m&quot; on a busy server.</p>
<p>The OS caps it at a maximum, on linux Unbound needs root permission to
bypass the limit, or the admin can use <code class="docutils literal notranslate"><span class="pre">sysctl</span> <span class="pre">net.core.rmem_max</span></code>.</p>
<p>On BSD change <code class="docutils literal notranslate"><span class="pre">kern.ipc.maxsockbuf</span></code> in <code class="docutils literal notranslate"><span class="pre">/etc/sysctl.conf</span></code>.</p>
<p>On OpenBSD change header and recompile kernel.</p>
<p>On Solaris <code class="docutils literal notranslate"><span class="pre">ndd</span> <span class="pre">-set</span> <span class="pre">/dev/udp</span> <span class="pre">udp_max_buf</span> <span class="pre">8388608</span></code>.</p>
<p>Default: 0 (use system value)</p>
</dd>
</dl>
<dl id="unbound-conf-so-sndbuf">
<dt>so-sndbuf: <em>&lt;number&gt;</em></dt><dd><p>If not 0, then set the SO_SNDBUF socket option to get more buffer space on
UDP port 53 outgoing queries.
This for very busy servers handles spikes in answer traffic, otherwise</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>send: resource temporarily unavailable
</pre></div>
</div>
<p>can get logged, the buffer overrun is also visible by <code class="docutils literal notranslate"><span class="pre">netstat</span> <span class="pre">-su</span></code>.
Specify the number of bytes to ask for, try &quot;4m&quot; on a very busy server.</p>
<p>The OS caps it at a maximum, on linux Unbound needs root permission to
bypass the limit, or the admin can use <code class="docutils literal notranslate"><span class="pre">sysctl</span> <span class="pre">net.core.wmem_max</span></code>.</p>
<p>On BSD, Solaris changes are similar to
<a class="reference internal" href="#unbound-conf-so-rcvbuf"><span class="std std-ref">so-rcvbuf:</span></a>.</p>
<p>Default: 0 (use system value)</p>
</dd>
</dl>
<dl id="unbound-conf-so-reuseport">
<dt>so-reuseport: <em>&lt;yes or no&gt;</em></dt><dd><p>If yes, then open dedicated listening sockets for incoming queries for each
thread and try to set the SO_REUSEPORT socket option on each socket.
May distribute incoming queries to threads more evenly.</p>
<p>On Linux it is supported in kernels &gt;= 3.9.</p>
<p>On other systems, FreeBSD, OSX it may also work.</p>
<p>You can enable it (on any platform and kernel), it then attempts to open
the port and passes the option if it was available at compile time, if that
works it is used, if it fails, it continues silently (unless verbosity 3)
without the option.</p>
<p>At extreme load it could be better to turn it off to distribute the queries
evenly, reported for Linux systems (4.4.x).</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-ip-transparent">
<dt>ip-transparent: <em>&lt;yes or no&gt;</em></dt><dd><p>If yes, then use IP_TRANSPARENT socket option on sockets where Unbound is
listening for incoming traffic.
Allows you to bind to non-local interfaces.
For example for non-existent IP addresses that are going to exist later on,
with host failover configuration.</p>
<p>This is a lot like
<a class="reference internal" href="#unbound-conf-interface-automatic"><span class="std std-ref">interface-automatic:</span></a>, but that one
services all interfaces and with this option you can select which (future)
interfaces Unbound provides service on.</p>
<p>This option needs Unbound to be started with root permissions on some
systems.
The option uses IP_BINDANY on FreeBSD systems and SO_BINDANY on OpenBSD
systems.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-ip-freebind">
<dt>ip-freebind: <em>&lt;yes or no&gt;</em></dt><dd><p>If yes, then use IP_FREEBIND socket option on sockets where Unbound is
listening to incoming traffic.
Allows you to bind to IP addresses that are nonlocal or do not exist, like
when the network interface or IP address is down.</p>
<p>Exists only on Linux, where the similar
<a class="reference internal" href="#unbound-conf-ip-transparent"><span class="std std-ref">ip-transparent:</span></a> option is also
available.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ip-dscp">
<dt>ip-dscp: <em>&lt;number&gt;</em></dt><dd><p>The value of the Differentiated Services Codepoint (DSCP) in the
differentiated services field (DS) of the outgoing IP packet headers.
The field replaces the outdated IPv4 Type-Of-Service field and the IPv6
traffic class field.</p>
</dd>
</dl>
<dl id="unbound-conf-rrset-cache-size">
<dt>rrset-cache-size: <em>&lt;number&gt;</em></dt><dd><p>Number of bytes size of the RRset cache.
A plain number is in bytes, append 'k', 'm' or 'g' for kilobytes, megabytes
or gigabytes (1024*1024 bytes in a megabyte).</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-rrset-cache-slabs">
<dt>rrset-cache-slabs: <em>&lt;number&gt;</em></dt><dd><p>Number of slabs in the RRset cache.
Slabs reduce lock contention by threads.
Must be set to a power of 2.</p>
<p>Default: 4</p>
</dd>
</dl>
<dl id="unbound-conf-cache-max-ttl">
<dt>cache-max-ttl: <em>&lt;seconds&gt;</em></dt><dd><p>Time to live maximum for RRsets and messages in the cache.
When the TTL expires, the cache item has expired.
Can be set lower to force the resolver to query for data often, and not
trust (very large) TTL values.
Downstream clients also see the lower TTL.</p>
<p>Default: 86400 (1 day)</p>
</dd>
</dl>
<dl id="unbound-conf-cache-min-ttl">
<dt>cache-min-ttl: <em>&lt;seconds&gt;</em></dt><dd><p>Time to live minimum for RRsets and messages in the cache.
If the minimum kicks in, the data is cached for longer than the domain
owner intended, and thus less queries are made to look up the data.
Zero makes sure the data in the cache is as the domain owner intended,
higher values, especially more than an hour or so, can lead to trouble as
the data in the cache does not match up with the actual data any more.</p>
<p>Default: 0 (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-cache-max-negative-ttl">
<dt>cache-max-negative-ttl: <em>&lt;seconds&gt;</em></dt><dd><p>Time to live maximum for negative responses, these have a SOA in the
authority section that is limited in time.
This applies to NXDOMAIN and NODATA answers.</p>
<p>Default: 3600</p>
</dd>
</dl>
<dl id="unbound-conf-infra-host-ttl">
<dt>infra-host-ttl: <em>&lt;seconds&gt;</em></dt><dd><p>Time to live for entries in the host cache.
The host cache contains roundtrip timing, lameness and EDNS support
information.</p>
<p>Default: 900</p>
</dd>
</dl>
<dl id="unbound-conf-infra-cache-slabs">
<dt>infra-cache-slabs: <em>&lt;number&gt;</em></dt><dd><p>Number of slabs in the infrastructure cache.
Slabs reduce lock contention by threads.
Must be set to a power of 2.</p>
<p>Default: 4</p>
</dd>
</dl>
<dl id="unbound-conf-infra-cache-numhosts">
<dt>infra-cache-numhosts: <em>&lt;number&gt;</em></dt><dd><p>Number of hosts for which information is cached.</p>
<p>Default: 10000</p>
</dd>
</dl>
<dl id="unbound-conf-infra-cache-min-rtt">
<dt>infra-cache-min-rtt: <em>&lt;msec&gt;</em></dt><dd><p>Lower limit for dynamic retransmit timeout calculation in infrastructure
cache.
Increase this value if using forwarders needing more time to do recursive
name resolution.</p>
<p>Default: 50</p>
</dd>
</dl>
<dl id="unbound-conf-infra-cache-max-rtt">
<dt>infra-cache-max-rtt: <em>&lt;msec&gt;</em></dt><dd><p>Upper limit for dynamic retransmit timeout calculation in infrastructure
cache.</p>
<p>Default: 120000 (2 minutes)</p>
</dd>
</dl>
<dl id="unbound-conf-infra-keep-probing">
<dt>infra-keep-probing: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled the server keeps probing hosts that are down, in the one probe
at a time regime.
Hosts that are down, eg. they did not respond during the one probe at a
time period, are marked as down and it may take
<a class="reference internal" href="#unbound-conf-infra-host-ttl"><span class="std std-ref">infra-host-ttl:</span></a> time to get probed
again.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-define-tag">
<dt>define-tag: <em>&quot;&lt;list of tags&gt;&quot;</em></dt><dd><p>Define the tags that can be used with
<a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> and
<a class="reference internal" href="#unbound-conf-access-control"><span class="std std-ref">access-control:</span></a>.
Enclose the list between quotes (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>) and put spaces between tags.</p>
</dd>
</dl>
<dl id="unbound-conf-do-ip4">
<dt>do-ip4: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable or disable whether IPv4 queries are answered or issued.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-do-ip6">
<dt>do-ip6: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable or disable whether IPv6 queries are answered or issued.
If disabled, queries are not answered on IPv6, and queries are not sent on
IPv6 to the internet nameservers.
With this option you can disable the IPv6 transport for sending DNS
traffic, it does not impact the contents of the DNS traffic, which may have
IPv4 (A) and IPv6 (AAAA) addresses in it.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-prefer-ip4">
<dt>prefer-ip4: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, prefer IPv4 transport for sending DNS queries to internet
nameservers.
Useful if the IPv6 netblock the server has, the entire /64 of that is not
owned by one operator and the reputation of the netblock /64 is an issue,
using IPv4 then uses the IPv4 filters that the upstream servers have.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-prefer-ip6">
<dt>prefer-ip6: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, prefer IPv6 transport for sending DNS queries to internet
nameservers.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-do-udp">
<dt>do-udp: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable or disable whether UDP queries are answered or issued.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-do-tcp">
<dt>do-tcp: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable or disable whether TCP queries are answered or issued.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-tcp-mss">
<dt>tcp-mss: <em>&lt;number&gt;</em></dt><dd><p>Maximum segment size (MSS) of TCP socket on which the server responds to
queries.
Value lower than common MSS on Ethernet (1220 for example) will address
path MTU problem.
Note that not all platform supports socket option to set MSS (TCP_MAXSEG).
Default is system default MSS determined by interface MTU and negotiation
between server and client.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-outgoing-tcp-mss">
<dt>outgoing-tcp-mss: <em>&lt;number&gt;</em></dt><dd><p>Maximum segment size (MSS) of TCP socket for outgoing queries (from Unbound
to other servers).
Value lower than common MSS on Ethernet (1220 for example) will address
path MTU problem.
Note that not all platform supports socket option to set MSS (TCP_MAXSEG).
Default is system default MSS determined by interface MTU and negotiation
between Unbound and other servers.</p>
</dd>
</dl>
<dl id="unbound-conf-tcp-idle-timeout">
<dt>tcp-idle-timeout: <em>&lt;msec&gt;</em></dt><dd><p>The period Unbound will wait for a query on a TCP connection.
If this timeout expires Unbound closes the connection.
When the number of free incoming TCP buffers falls below 50% of the total
number configured, the option value used is progressively reduced, first to
1% of the configured value, then to 0.2% of the configured value if the
number of free buffers falls below 35% of the total number configured, and
finally to 0 if the number of free buffers falls below 20% of the total
number configured.
A minimum timeout of 200 milliseconds is observed regardless of the option
value used.</p>
<p>Default: 30000 (30 seconds)</p>
</dd>
</dl>
<dl id="unbound-conf-tcp-reuse-timeout">
<dt>tcp-reuse-timeout: <em>&lt;msec&gt;</em></dt><dd><p>The period Unbound will keep TCP persistent connections open to authority
servers.</p>
<p>Default: 60000 (60 seconds)</p>
</dd>
</dl>
<dl id="unbound-conf-max-reuse-tcp-queries">
<dt>max-reuse-tcp-queries: <em>&lt;number&gt;</em></dt><dd><p>The maximum number of queries that can be sent on a persistent TCP
connection.</p>
<p>Default: 200</p>
</dd>
</dl>
<dl id="unbound-conf-tcp-auth-query-timeout">
<dt>tcp-auth-query-timeout: <em>&lt;number&gt;</em></dt><dd><p>Timeout in milliseconds for TCP queries to auth servers.</p>
<p>Default: 3000 (3 seconds)</p>
</dd>
</dl>
<dl id="unbound-conf-edns-tcp-keepalive">
<dt>edns-tcp-keepalive: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable or disable EDNS TCP Keepalive.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-edns-tcp-keepalive-timeout">
<dt>edns-tcp-keepalive-timeout: <em>&lt;msec&gt;</em></dt><dd><p>The period Unbound will wait for a query on a TCP connection when EDNS TCP
Keepalive is active.
If this timeout expires Unbound closes the connection.
If the client supports the EDNS TCP Keepalive option, Unbound sends the
timeout value to the client to encourage it to close the connection before
the server times out.</p>
<p>When the number of free incoming TCP buffers falls below 50% of the total
number configured, the advertised timeout is progressively reduced to 1% of
the configured value, then to 0.2% of the configured value if the number of
free buffers falls below 35% of the total number configured, and finally to
0 if the number of free buffers falls below 20% of the total number
configured.
A minimum actual timeout of 200 milliseconds is observed regardless of the
advertised timeout.</p>
<p>Default: 120000 (2 minutes)</p>
</dd>
</dl>
<dl id="unbound-conf-sock-queue-timeout">
<dt>sock-queue-timeout: <em>&lt;sec&gt;</em></dt><dd><p>UDP queries that have waited in the socket buffer for a long time can be
dropped.
The time is set in seconds, 3 could be a good value to ignore old queries
that likely the client does not need a reply for any more.
This could happen if the host has not been able to service the queries for
a while, i.e. Unbound is not running, and then is enabled again.
It uses timestamp socket options.</p>
<p>Default: 0 (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-tcp-upstream">
<dt>tcp-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable or disable whether the upstream queries use TCP only for transport.
Useful in tunneling scenarios.
If set to no you can specify TCP transport only for selected forward or
stub zones using
<a class="reference internal" href="#unbound-conf-forward-forward-tcp-upstream"><span class="std std-ref">forward-tcp-upstream:</span></a> or
<a class="reference internal" href="#unbound-conf-stub-stub-tcp-upstream"><span class="std std-ref">stub-tcp-upstream:</span></a>
respectively.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-udp-upstream-without-downstream">
<dt>udp-upstream-without-downstream: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable UDP upstream even if <a class="reference internal" href="#unbound-conf-do-udp"><span class="std std-ref">do-udp:</span></a> is no.
Useful for TLS service providers, that want no UDP downstream but use UDP
to fetch data upstream.</p>
<p>Default: no (no changes)</p>
</dd>
</dl>
<dl id="unbound-conf-tls-upstream">
<dt>tls-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>Enabled or disable whether the upstream queries use TLS only for transport.
Useful in tunneling scenarios.
The TLS contains plain DNS in TCP wireformat.
The other server must support this (see
<a class="reference internal" href="#unbound-conf-tls-service-key"><span class="std std-ref">tls-service-key:</span></a>).</p>
<p>If you enable this, also configure a
<a class="reference internal" href="#unbound-conf-tls-cert-bundle"><span class="std std-ref">tls-cert-bundle:</span></a> or use
<a class="reference internal" href="#unbound-conf-tls-win-cert"><span class="std std-ref">tls-win-cert:</span></a> or
<a class="reference internal" href="#unbound-conf-tls-system-cert"><span class="std std-ref">tls-system-cert:</span></a> to load CA certs,
otherwise the connections cannot be authenticated.</p>
<p>This option enables TLS for all of them, but if you do not set this you can
configure TLS specifically for some forward zones with
<a class="reference internal" href="#unbound-conf-forward-forward-tls-upstream"><span class="std std-ref">forward-tls-upstream:</span></a>.
And also with
<a class="reference internal" href="#unbound-conf-stub-stub-tls-upstream"><span class="std std-ref">stub-tls-upstream:</span></a>.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ssl-upstream">
<dt>ssl-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>Alternate syntax for <a class="reference internal" href="#unbound-conf-tls-upstream"><span class="std std-ref">tls-upstream:</span></a>.
If both are present in the config file the last is used.</p>
</dd>
</dl>
<dl id="unbound-conf-tls-service-key">
<dt>tls-service-key: <em>&lt;file&gt;</em></dt><dd><p>If enabled, the server provides DNS-over-TLS or DNS-over-HTTPS service on
the TCP ports marked implicitly or explicitly for these services with
<a class="reference internal" href="#unbound-conf-tls-port"><span class="std std-ref">tls-port:</span></a> or
<a class="reference internal" href="#unbound-conf-https-port"><span class="std std-ref">https-port:</span></a>.
The file must contain the private key for the TLS session, the public
certificate is in the <a class="reference internal" href="#unbound-conf-tls-service-pem"><span class="std std-ref">tls-service-pem:</span></a>
file and it must also be specified if
<a class="reference internal" href="#unbound-conf-tls-service-key"><span class="std std-ref">tls-service-key:</span></a> is specified.
Enabling or disabling this service requires a restart (a reload is not
enough), because the key is read while root permissions are held and before
chroot (if any).
The ports enabled implicitly or explicitly via
<a class="reference internal" href="#unbound-conf-tls-port"><span class="std std-ref">tls-port:</span></a> and
<a class="reference internal" href="#unbound-conf-https-port"><span class="std std-ref">https-port:</span></a> do not provide normal DNS TCP
service.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Unbound needs to be compiled with libnghttp2 in order to provide
DNS-over-HTTPS.</p>
</div>
<p>Default: &quot;&quot; (disabled)</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ssl-service-key">
<dt>ssl-service-key: <em>&lt;file&gt;</em></dt><dd><p>Alternate syntax for <a class="reference internal" href="#unbound-conf-tls-service-key"><span class="std std-ref">tls-service-key:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-tls-service-pem">
<dt>tls-service-pem: <em>&lt;file&gt;</em></dt><dd><p>The public key certificate pem file for the tls service.</p>
<p>Default: &quot;&quot; (disabled)</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ssl-service-pem">
<dt>ssl-service-pem: <em>&lt;file&gt;</em></dt><dd><p>Alternate syntax for <a class="reference internal" href="#unbound-conf-tls-service-pem"><span class="std std-ref">tls-service-pem:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-tls-port">
<dt>tls-port: <em>&lt;number&gt;</em></dt><dd><p>The port number on which to provide TCP TLS service.
Only interfaces configured with that port number as &#64;number get the TLS
service.</p>
<p>Default: 853</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ssl-port">
<dt>ssl-port: <em>&lt;number&gt;</em></dt><dd><p>Alternate syntax for <a class="reference internal" href="#unbound-conf-tls-port"><span class="std std-ref">tls-port:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-tls-cert-bundle">
<dt>tls-cert-bundle: <em>&lt;file&gt;</em></dt><dd><p>If null or <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, no file is used.
Set it to the certificate bundle file, for example
<code class="file docutils literal notranslate"><span class="pre">/etc/pki/tls/certs/ca-bundle.crt</span></code>.
These certificates are used for authenticating connections made to outside
peers.
For example <a class="reference internal" href="#unbound-conf-auth-url"><span class="std std-ref">auth-zone urls:</span></a>, and also
DNS-over-TLS connections.
It is read at start up before permission drop and chroot.</p>
<p>Default: &quot;&quot; (disabled)</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ssl-cert-bundle">
<dt>ssl-cert-bundle: <em>&lt;file&gt;</em></dt><dd><p>Alternate syntax for <a class="reference internal" href="#unbound-conf-tls-cert-bundle"><span class="std std-ref">tls-cert-bundle:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-tls-win-cert">
<dt>tls-win-cert: <em>&lt;yes or no&gt;</em></dt><dd><p>Add the system certificates to the cert bundle certificates for
authentication.
If no cert bundle, it uses only these certificates.
On windows this option uses the certificates from the cert store.
Use the <a class="reference internal" href="#unbound-conf-tls-cert-bundle"><span class="std std-ref">tls-cert-bundle:</span></a> option on
other systems.
On other systems, this option enables the system certificates.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-tls-system-cert">
<dt>tls-system-cert: <em>&lt;yes or no&gt;</em></dt><dd><p>This the same attribute as the
<a class="reference internal" href="#unbound-conf-tls-win-cert"><span class="std std-ref">tls-win-cert:</span></a> attribute, under a
different name.
Because it is not windows specific.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-tls-additional-port">
<dt>tls-additional-port: <em>&lt;portnr&gt;</em></dt><dd><p>List port numbers as
<a class="reference internal" href="#unbound-conf-tls-additional-port"><span class="std std-ref">tls-additional-port:</span></a>, and when
interfaces are defined, eg. with the &#64;port suffix, as this port number,
they provide DNS-over-TLS service.
Can list multiple, each on a new statement.</p>
</dd>
</dl>
<dl id="unbound-conf-tls-session-ticket-keys">
<dt>tls-session-ticket-keys: <em>&lt;file&gt;</em></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, lists files with 80 bytes of random contents that are used
to perform TLS session resumption for clients using the Unbound server.
These files contain the secret key for the TLS session tickets.
First key use to encrypt and decrypt TLS session tickets.
Other keys use to decrypt only.</p>
<p>With this you can roll over to new keys, by generating a new first file and
allowing decrypt of the old file by listing it after the first file for
some time, after the wait clients are not using the old key any more and
the old key can be removed.
One way to create the file is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>dd if=/dev/random bs=1 count=80 of=ticket.dat
</pre></div>
</div>
<p>The first 16 bytes should be different from the old one if you create a
second key, that is the name used to identify the key.
Then there is 32 bytes random data for an AES key and then 32 bytes random
data for the HMAC key.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-tls-ciphers">
<dt>tls-ciphers: <em>&lt;string with cipher list&gt;</em></dt><dd><p>Set the list of ciphers to allow when serving TLS.
Use <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> for default ciphers.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-tls-ciphersuites">
<dt>tls-ciphersuites: <em>&lt;string with ciphersuites list&gt;</em></dt><dd><p>Set the list of ciphersuites to allow when serving TLS.
This is for newer TLS 1.3 connections.
Use <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> for default ciphersuites.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-pad-responses">
<dt>pad-responses: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, TLS serviced queries that contained an EDNS Padding option will
cause responses padded to the closest multiple of the size specified in
<a class="reference internal" href="#unbound-conf-pad-responses-block-size"><span class="std std-ref">pad-responses-block-size:</span></a>.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-pad-responses-block-size">
<dt>pad-responses-block-size: <em>&lt;number&gt;</em></dt><dd><p>The block size with which to pad responses serviced over TLS.
Only responses to padded queries will be padded.</p>
<p>Default: 468</p>
</dd>
</dl>
<dl id="unbound-conf-pad-queries">
<dt>pad-queries: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, all queries sent over TLS upstreams will be padded to the
closest multiple of the size specified in
<a class="reference internal" href="#unbound-conf-pad-queries-block-size"><span class="std std-ref">pad-queries-block-size:</span></a>.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-pad-queries-block-size">
<dt>pad-queries-block-size: <em>&lt;number&gt;</em></dt><dd><p>The block size with which to pad queries sent over TLS upstreams.</p>
<p>Default: 128</p>
</dd>
</dl>
<dl id="unbound-conf-tls-use-sni">
<dt>tls-use-sni: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable or disable sending the SNI extension on TLS connections.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Changing the value requires a reload.</p>
</div>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-https-port">
<dt>https-port: <em>&lt;number&gt;</em></dt><dd><p>The port number on which to provide DNS-over-HTTPS service.
Only interfaces configured with that port number as &#64;number get the HTTPS
service.</p>
<p>Default: 443</p>
</dd>
</dl>
<dl id="unbound-conf-http-endpoint">
<dt>http-endpoint: <em>&lt;endpoint string&gt;</em></dt><dd><p>The HTTP endpoint to provide DNS-over-HTTPS service on.</p>
<p>Default: /dns-query</p>
</dd>
</dl>
<dl id="unbound-conf-http-max-streams">
<dt>http-max-streams: <em>&lt;number of streams&gt;</em></dt><dd><p>Number used in the SETTINGS_MAX_CONCURRENT_STREAMS parameter in the HTTP/2
SETTINGS frame for DNS-over-HTTPS connections.</p>
<p>Default: 100</p>
</dd>
</dl>
<dl id="unbound-conf-http-query-buffer-size">
<dt>http-query-buffer-size: <em>&lt;size in bytes&gt;</em></dt><dd><p>Maximum number of bytes used for all HTTP/2 query buffers combined.
These buffers contain (partial) DNS queries waiting for request stream
completion.
An RST_STREAM frame will be send to streams exceeding this limit.
A plain number is in bytes, append 'k', 'm' or 'g' for kilobytes, megabytes
or gigabytes (1024*1024 bytes in a megabyte).</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-http-response-buffer-size">
<dt>http-response-buffer-size: <em>&lt;size in bytes&gt;</em></dt><dd><p>Maximum number of bytes used for all HTTP/2 response buffers combined.
These buffers contain DNS responses waiting to be written back to the
clients.
An RST_STREAM frame will be send to streams exceeding this limit.
A plain number is in bytes, append 'k', 'm' or 'g' for kilobytes, megabytes
or gigabytes (1024*1024 bytes in a megabyte).</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-http-nodelay">
<dt>http-nodelay: <em>&lt;yes or no&gt;</em></dt><dd><p>Set TCP_NODELAY socket option on sockets used to provide DNS-over-HTTPS
service.
Ignored if the option is not available.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-http-notls-downstream">
<dt>http-notls-downstream: <em>&lt;yes or no&gt;</em></dt><dd><p>Disable use of TLS for the downstream DNS-over-HTTP connections.
Useful for local back end servers.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-proxy-protocol-port">
<dt>proxy-protocol-port: <em>&lt;portnr&gt;</em></dt><dd><p>List port numbers as
<a class="reference internal" href="#unbound-conf-proxy-protocol-port"><span class="std std-ref">proxy-protocol-port:</span></a>, and when
interfaces are defined, eg. with the &#64;port suffix, as this port number,
they support and expect PROXYv2.</p>
<p>In this case the proxy address will only be used for the network
communication and initial ACL (check if the proxy itself is denied/refused
by configuration).</p>
<p>The proxied address (if any) will then be used as the true client address
and will be used where applicable for logging, ACL, DNSTAP, RPZ and IP
ratelimiting.</p>
<p>PROXYv2 is supported for UDP and TCP/TLS listening interfaces.</p>
<p>There is no support for PROXYv2 on a DoH or DNSCrypt listening interface.</p>
<p>Can list multiple, each on a new statement.</p>
</dd>
</dl>
<dl id="unbound-conf-use-systemd">
<dt>use-systemd: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable or disable systemd socket activation.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-do-daemonize">
<dt>do-daemonize: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable or disable whether the Unbound server forks into the background as a
daemon.
Set the value to no when Unbound runs as systemd service.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-tcp-connection-limit">
<dt>tcp-connection-limit: <em>&lt;IP netblock&gt; &lt;limit&gt;</em></dt><dd><p>Allow up to limit simultaneous TCP connections from the given netblock.
When at the limit, further connections are accepted but closed immediately.
This option is experimental at this time.</p>
<p>Default: (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-access-control">
<dt>access-control: <em>&lt;IP netblock&gt; &lt;action&gt;</em></dt><dd><p>The netblock is given as an IPv4 or IPv6 address with /size appended for a
classless network block.
The most specific netblock match is used, if none match
<a class="reference internal" href="#unbound-conf-access-control-action-refuse"><span class="std std-ref">refuse</span></a> is used.
The order of the access-control statements therefore does not matter.
The action can be
<a class="reference internal" href="#unbound-conf-access-control-action-deny"><span class="std std-ref">deny</span></a>,
<a class="reference internal" href="#unbound-conf-access-control-action-refuse"><span class="std std-ref">refuse</span></a>,
<a class="reference internal" href="#unbound-conf-access-control-action-allow"><span class="std std-ref">allow</span></a>,
<a class="reference internal" href="#unbound-conf-access-control-action-allow-setrd"><span class="std std-ref">allow_setrd</span></a>,
<a class="reference internal" href="#unbound-conf-access-control-action-allow-snoop"><span class="std std-ref">allow_snoop</span></a>,
<a class="reference internal" href="#unbound-conf-access-control-action-allow-cookie"><span class="std std-ref">allow_cookie</span></a>,
<a class="reference internal" href="#unbound-conf-access-control-action-deny-non-local"><span class="std std-ref">deny_non_local</span></a> or
<a class="reference internal" href="#unbound-conf-access-control-action-refuse-non-local"><span class="std std-ref">refuse_non_local</span></a>.</p>
<dl class="simple" id="unbound-conf-access-control-action-deny">
<dt>deny</dt><dd><p>Stops queries from hosts from that netblock.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-access-control-action-refuse">
<dt>refuse</dt><dd><p>Stops queries too, but sends a DNS rcode REFUSED error message back.</p>
</dd>
</dl>
<dl id="unbound-conf-access-control-action-allow">
<dt>allow</dt><dd><p>Gives access to clients from that netblock.
It gives only access for recursion clients (which is what almost all
clients need).
Non-recursive queries are refused.</p>
<p>The <a class="reference internal" href="#unbound-conf-access-control-action-allow"><span class="std std-ref">allow</span></a> action does
allow non-recursive queries to access the local-data that is
configured.
The reason is that this does not involve the Unbound server recursive
lookup algorithm, and static data is served in the reply.
This supports normal operations where non-recursive queries are made
for the authoritative data.
For non-recursive queries any replies from the dynamic cache are
refused.</p>
</dd>
</dl>
<dl id="unbound-conf-access-control-action-allow-setrd">
<dt>allow_setrd</dt><dd><p>Ignores the recursion desired (RD) bit and treats all requests as if
the recursion desired bit is set.</p>
<p>Note that this behavior violates <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1034.html"><strong>RFC 1034</strong></a> which states that a name
server should never perform recursive service unless asked via the RD
bit since this interferes with trouble shooting of name servers and
their databases.
This prohibited behavior may be useful if another DNS server must
forward requests for specific zones to a resolver DNS server, but only
supports stub domains and sends queries to the resolver DNS server with
the RD bit cleared.</p>
</dd>
</dl>
<dl id="unbound-conf-access-control-action-allow-snoop">
<dt>allow_snoop</dt><dd><p>Gives non-recursive access too.
This gives both recursive and non recursive access.
The name <em>allow_snoop</em> refers to cache snooping, a technique to use
non-recursive queries to examine the cache contents (for malicious
acts).
However, non-recursive queries can also be a valuable debugging tool
(when you want to examine the cache contents).</p>
<p>In that case use
<a class="reference internal" href="#unbound-conf-access-control-action-allow-snoop"><span class="std std-ref">allow_snoop</span></a> for
your administration host.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-access-control-action-allow-cookie">
<dt>allow_cookie</dt><dd><p>Allows access to UDP queries that contain a valid DNS Cookie as
specified in RFC 7873 and RFC 9018, when the
<a class="reference internal" href="#unbound-conf-answer-cookie"><span class="std std-ref">answer-cookie:</span></a> option is enabled.
UDP queries containing only a DNS Client Cookie and no Server Cookie,
or an invalid DNS Cookie, will receive a BADCOOKIE response including a
newly generated DNS Cookie, allowing clients to retry with that DNS
Cookie.
The <em>allow_cookie</em> action will also accept requests over stateful
transports, regardless of the presence of an DNS Cookie and regardless
of the <a class="reference internal" href="#unbound-conf-answer-cookie"><span class="std std-ref">answer-cookie:</span></a> setting.
If <a class="reference internal" href="#unbound-conf-ip-ratelimit"><span class="std std-ref">ip-ratelimit:</span></a> is used, clients
with a valid DNS Cookie will bypass the ratelimit.
If a ratelimit for such clients is still needed,
<a class="reference internal" href="#unbound-conf-ip-ratelimit-cookie"><span class="std std-ref">ip-ratelimit-cookie:</span></a> can be
used instead.</p>
</dd>
</dl>
<span id="unbound-conf-access-control-action-deny-non-local"></span><dl id="unbound-conf-access-control-action-refuse-non-local">
<dt>deny_non_local, refuse_non_local</dt><dd><p>The
<a class="reference internal" href="#unbound-conf-access-control-action-deny-non-local"><span class="std std-ref">deny_non_local</span></a>
and
<a class="reference internal" href="#unbound-conf-access-control-action-refuse-non-local"><span class="std std-ref">refuse_non_local</span></a>
actions are for hosts that are only allowed to query for the
authoritative <a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a>, they are not
allowed full recursion but only the static data.</p>
<p>With
<a class="reference internal" href="#unbound-conf-access-control-action-deny-non-local"><span class="std std-ref">deny_non_local</span></a>,
messages that are disallowed are dropped, with
<a class="reference internal" href="#unbound-conf-access-control-action-refuse-non-local"><span class="std std-ref">refuse_non_local</span></a>
they receive error code REFUSED.</p>
</dd>
</dl>
<p>By default only localhost is <em>allowed</em>, the rest is refused.
The default is <em>refused</em>, because that is protocol-friendly.
The DNS protocol is not designed to handle dropped packets due to policy,
and dropping may result in (possibly excessive) retried queries.</p>
</dd>
</dl>
<dl id="unbound-conf-access-control-tag">
<dt>access-control-tag: <em>&lt;IP netblock&gt; &quot;&lt;list of tags&gt;&quot;</em></dt><dd><p>Assign tags to <a class="reference internal" href="#unbound-conf-access-control"><span class="std std-ref">access-control:</span></a>
elements.
Clients using this access control element use localzones that are tagged
with one of these tags.</p>
<p>Tags must be defined in <a class="reference internal" href="#unbound-conf-define-tag"><span class="std std-ref">define-tag:</span></a>.
Enclose list of tags in quotes (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>) and put spaces between tags.</p>
<p>If <a class="reference internal" href="#unbound-conf-access-control-tag"><span class="std std-ref">access-control-tag:</span></a> is
configured for a netblock that does not have an
<a class="reference internal" href="#unbound-conf-access-control"><span class="std std-ref">access-control:</span></a>, an access-control
element with action <a class="reference internal" href="#unbound-conf-access-control-action-allow"><span class="std std-ref">allow</span></a>
is configured for this netblock.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-access-control-tag-action">
<dt>access-control-tag-action: <em>&lt;IP netblock&gt; &lt;tag&gt; &lt;action&gt;</em></dt><dd><p>Set action for particular tag for given access control element.
If you have multiple tag values, the tag used to lookup the action is the
first tag match between
<a class="reference internal" href="#unbound-conf-access-control-tag"><span class="std std-ref">access-control-tag:</span></a> and
<a class="reference internal" href="#unbound-conf-local-zone-tag"><span class="std std-ref">local-zone-tag:</span></a> where &quot;first&quot; comes
from the order of the <a class="reference internal" href="#unbound-conf-define-tag"><span class="std std-ref">define-tag:</span></a> values.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-access-control-tag-data">
<dt>access-control-tag-data: <em>&lt;IP netblock&gt; &lt;tag&gt; &quot;&lt;resource record string&gt;&quot;</em></dt><dd><p>Set redirect data for particular tag for given access control element.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-access-control-view">
<dt>access-control-view: <em>&lt;IP netblock&gt; &lt;view name&gt;</em></dt><dd><p>Set view for given access control element.</p>
</dd>
</dl>
<dl id="unbound-conf-interface-action">
<dt>interface-action: <em>&lt;ip address or interface name [&#64;port]&gt; &lt;action&gt;</em></dt><dd><p>Similar to <a class="reference internal" href="#unbound-conf-access-control"><span class="std std-ref">access-control:</span></a> but for
interfaces.</p>
<p>The action is the same as the ones defined under
<a class="reference internal" href="#unbound-conf-access-control"><span class="std std-ref">access-control:</span></a>.</p>
<p>Default action for interfaces is
<a class="reference internal" href="#unbound-conf-access-control-action-refuse"><span class="std std-ref">refuse</span></a>.
By default only localhost (the IP netblock, not the loopback interface) is
allowed through the default
<a class="reference internal" href="#unbound-conf-access-control"><span class="std std-ref">access-control:</span></a> behavior.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The interface needs to be already specified with
<a class="reference internal" href="#unbound-conf-interface"><span class="std std-ref">interface:</span></a> and that any
<strong>access-control*:</strong> attribute overrides all <strong>interface-*:</strong>
attributes for targeted clients.</p>
</div>
</dd>
</dl>
<dl id="unbound-conf-interface-tag">
<dt>interface-tag: <em>&lt;ip address or interface name [&#64;port]&gt; &lt;&quot;list of tags&quot;&gt;</em></dt><dd><p>Similar to <a class="reference internal" href="#unbound-conf-access-control-tag"><span class="std std-ref">access-control-tag:</span></a> but
for interfaces.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The interface needs to be already specified with
<a class="reference internal" href="#unbound-conf-interface"><span class="std std-ref">interface:</span></a> and that any
<strong>access-control*:</strong> attribute overrides all <strong>interface-*:</strong>
attributes for targeted clients.</p>
</div>
</dd>
</dl>
<dl id="unbound-conf-interface-tag-action">
<dt>interface-tag-action: <em>&lt;ip address or interface name [&#64;port]&gt; &lt;tag&gt; &lt;action&gt;</em></dt><dd><p>Similar to
<a class="reference internal" href="#unbound-conf-access-control-tag-action"><span class="std std-ref">access-control-tag-action:</span></a>
but for interfaces.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The interface needs to be already specified with
<a class="reference internal" href="#unbound-conf-interface"><span class="std std-ref">interface:</span></a> and that any
<strong>access-control*:</strong> attribute overrides all <strong>interface-*:</strong>
attributes for targeted clients.</p>
</div>
</dd>
</dl>
<dl id="unbound-conf-interface-tag-data">
<dt>interface-tag-data: <em>&lt;ip address or interface name [&#64;port]&gt; &lt;tag&gt; &lt;&quot;resource record string&quot;&gt;</em></dt><dd><p>Similar to
<a class="reference internal" href="#unbound-conf-access-control-tag-data"><span class="std std-ref">access-control-tag-data:</span></a> but
for interfaces.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The interface needs to be already specified with
<a class="reference internal" href="#unbound-conf-interface"><span class="std std-ref">interface:</span></a> and that any
<strong>access-control*:</strong> attribute overrides all <strong>interface-*:</strong>
attributes for targeted clients.</p>
</div>
</dd>
</dl>
<dl id="unbound-conf-interface-view">
<dt>interface-view: <em>&lt;ip address or interface name [&#64;port]&gt; &lt;view name&gt;</em></dt><dd><p>Similar to <a class="reference internal" href="#unbound-conf-access-control-view"><span class="std std-ref">access-control-view:</span></a>
but for interfaces.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The interface needs to be already specified with
<a class="reference internal" href="#unbound-conf-interface"><span class="std std-ref">interface:</span></a> and that any
<strong>access-control*:</strong> attribute overrides all <strong>interface-*:</strong>
attributes for targeted clients.</p>
</div>
</dd>
</dl>
<dl id="unbound-conf-chroot">
<dt>chroot: <em>&lt;directory&gt;</em></dt><dd><p>If <a class="reference internal" href="#unbound-conf-chroot"><span class="std std-ref">chroot:</span></a> is enabled, you should pass the
configfile (from the commandline) as a full path from the original root.
After the chroot has been performed the now defunct portion of the config
file path is removed to be able to reread the config after a reload.</p>
<p>All other file paths (working dir, logfile, roothints, and key files) can
be specified in several ways: as an absolute path relative to the new root,
as a relative path to the working directory, or as an absolute path
relative to the original root.
In the last case the path is adjusted to remove the unused portion.</p>
<p>The pidfile can be either a relative path to the working directory, or an
absolute path relative to the original root.
It is written just prior to chroot and dropping permissions.
This allows the pidfile to be <code class="file docutils literal notranslate"><span class="pre">/var/run/unbound.pid</span></code> and the chroot
to be <code class="file docutils literal notranslate"><span class="pre">/var/unbound</span></code>, for example.
Note that Unbound is not able to remove the pidfile after termination when
it is located outside of the chroot directory.</p>
<p>Additionally, Unbound may need to access <code class="file docutils literal notranslate"><span class="pre">/dev/urandom</span></code> (for entropy)
from inside the chroot.</p>
<p>If given, a <em>chroot(2)</em> is done to the given directory.
If you give <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> no <em>chroot(2)</em> is performed.</p>
<p>Default: /usr/local/etc/unbound</p>
</dd>
</dl>
<dl id="unbound-conf-username">
<dt>username: <em>&lt;name&gt;</em></dt><dd><p>If given, after binding the port the user privileges are dropped.
If you give username: <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> no user change is performed.</p>
<p>If this user is not capable of binding the port, reloads (by signal HUP)
will still retain the opened ports.
If you change the port number in the config file, and that new port number
requires privileges, then a reload will fail; a restart is needed.</p>
<p>Default: unbound</p>
</dd>
</dl>
<dl id="unbound-conf-directory">
<dt>directory: <em>&lt;directory&gt;</em></dt><dd><p>Sets the working directory for the program.
On Windows the string &quot;%EXECUTABLE%&quot; tries to change to the directory that
<strong class="command">unbound.exe</strong> resides in.
If you give a <a class="reference internal" href="#unbound-conf-directory"><span class="std std-ref">server: directory:
&lt;directory&gt;</span></a> before
<a class="reference internal" href="#unbound-conf-include"><span class="std std-ref">include:</span></a> file statements then those includes
can be relative to the working directory.</p>
<p>Default: /usr/local/etc/unbound</p>
</dd>
</dl>
<dl id="unbound-conf-logfile">
<dt>logfile: <em>&lt;filename&gt;</em></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> is given, logging goes to stderr, or nowhere once daemonized.
The logfile is appended to, in the following format:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[seconds since 1970] unbound[pid:tid]: type: message.
</pre></div>
</div>
<p>If this option is given, the <a class="reference internal" href="#unbound-conf-use-syslog"><span class="std std-ref">use-syslog:</span></a>
attribute is set to &quot;no&quot;.
The logfile is reopened (for append) when the config file is reread, on
SIGHUP.</p>
<p>Default: &quot;&quot; (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-use-syslog">
<dt>use-syslog: <em>&lt;yes or no&gt;</em></dt><dd><p>Sets Unbound to send log messages to the syslogd, using <em>syslog(3)</em>.
The log facility LOG_DAEMON is used, with identity &quot;unbound&quot;.
The logfile setting is overridden when
<a class="reference internal" href="#unbound-conf-use-syslog"><span class="std std-ref">use-syslog:</span></a> is turned on.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-log-identity">
<dt>log-identity: <em>&lt;string&gt;</em></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> is given, then the name of the executable, usually
&quot;unbound&quot; is used to report to the log.
Enter a string to override it with that, which is useful on systems that
run more than one instance of Unbound, with different configurations, so
that the logs can be easily distinguished against.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-log-time-ascii">
<dt>log-time-ascii: <em>&lt;yes or no&gt;</em></dt><dd><p>Sets logfile lines to use a timestamp in UTC ASCII.
No effect if using syslog, in that case syslog formats the timestamp
printed into the log files.</p>
<p>Default: no (prints the seconds since 1970 in brackets)</p>
</dd>
</dl>
<dl id="unbound-conf-log-queries">
<dt>log-queries: <em>&lt;yes or no&gt;</em></dt><dd><p>Prints one line per query to the log, with the log timestamp and IP
address, name, type and class.
Note that it takes time to print these lines which makes the server
(significantly) slower.
Odd (nonprintable) characters in names are printed as <code class="docutils literal notranslate"><span class="pre">'?'</span></code>.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-log-replies">
<dt>log-replies: <em>&lt;yes or no&gt;</em></dt><dd><p>Prints one line per reply to the log, with the log timestamp and IP
address, name, type, class, return code, time to resolve, from cache and
response size.
Note that it takes time to print these lines which makes the server
(significantly) slower.
Odd (nonprintable) characters in names are printed as <code class="docutils literal notranslate"><span class="pre">'?'</span></code>.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-log-tag-queryreply">
<dt>log-tag-queryreply: <em>&lt;yes or no&gt;</em></dt><dd><p>Prints the word 'query' and 'reply' with
<a class="reference internal" href="#unbound-conf-log-queries"><span class="std std-ref">log-queries:</span></a> and
<a class="reference internal" href="#unbound-conf-log-replies"><span class="std std-ref">log-replies:</span></a>.
This makes filtering logs easier.</p>
<p>Default: no (backwards compatible)</p>
</dd>
</dl>
<dl id="unbound-conf-log-local-actions">
<dt>log-local-actions: <em>&lt;yes or no&gt;</em></dt><dd><p>Print log lines to inform about local zone actions.
These lines are like the <a class="reference internal" href="#unbound-conf-local-zone-type-inform"><span class="std std-ref">local-zone type
inform</span></a> print outs, but they are also
printed for the other types of local zones.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-log-servfail">
<dt>log-servfail: <em>&lt;yes or no&gt;</em></dt><dd><p>Print log lines that say why queries return SERVFAIL to clients.
This is separate from the verbosity debug logs, much smaller, and printed
at the error level, not the info level of debug info from verbosity.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-pidfile">
<dt>pidfile: <em>&lt;filename&gt;</em></dt><dd><p>The process id is written to the file.
Default is <code class="file docutils literal notranslate"><span class="pre">&quot;/usr/local/etc/unbound/unbound.pid&quot;</span></code>.
So,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">kill</span><span class="w"> </span>-HUP<span class="w"> </span><span class="sb">`</span>cat<span class="w"> </span>/usr/local/etc/unbound/unbound.pid<span class="sb">`</span>
</pre></div>
</div>
<p>triggers a reload,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">kill</span><span class="w"> </span>-TERM<span class="w"> </span><span class="sb">`</span>cat<span class="w"> </span>/usr/local/etc/unbound/unbound.pid<span class="sb">`</span>
</pre></div>
</div>
<p>gracefully terminates.</p>
<p>Default: /usr/local/etc/unbound/unbound.pid</p>
</dd>
</dl>
<dl id="unbound-conf-root-hints">
<dt>root-hints: <em>&lt;filename&gt;</em></dt><dd><p>Read the root hints from this file.
Default is nothing, using builtin hints for the IN class.
The file has the format of zone files, with root nameserver names and
addresses only.
The default may become outdated, when servers change, therefore it is good
practice to use a root hints file.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-hide-identity">
<dt>hide-identity: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled 'id.server' and 'hostname.bind' queries are REFUSED.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-identity">
<dt>identity: <em>&lt;string&gt;</em></dt><dd><p>Set the identity to report.
If set to <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, then the hostname of the server is returned.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-hide-version">
<dt>hide-version: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled 'version.server' and 'version.bind' queries are REFUSED.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-version">
<dt>version: <em>&lt;string&gt;</em></dt><dd><p>Set the version to report.
If set to <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, then the package version is returned.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-hide-http-user-agent">
<dt>hide-http-user-agent: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled the HTTP header User-Agent is not set.
Use with caution as some webserver configurations may reject HTTP requests
lacking this header.
If needed, it is better to explicitly set the
<a class="reference internal" href="#unbound-conf-http-user-agent"><span class="std std-ref">http-user-agent:</span></a> below.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-http-user-agent">
<dt>http-user-agent: <em>&lt;string&gt;</em></dt><dd><p>Set the HTTP User-Agent header for outgoing HTTP requests.
If set to <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, then the package name and version are used.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-nsid">
<dt>nsid: <em>&lt;string&gt;</em></dt><dd><p>Add the specified nsid to the EDNS section of the answer when queried with
an NSID EDNS enabled packet.
As a sequence of hex characters or with 'ascii_' prefix and then an ASCII
string.</p>
<p>Default: (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-hide-trustanchor">
<dt>hide-trustanchor: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled 'trustanchor.unbound' queries are REFUSED.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-target-fetch-policy">
<dt>target-fetch-policy: <em>&lt;&quot;list of numbers&quot;&gt;</em></dt><dd><p>Set the target fetch policy used by Unbound to determine if it should fetch
nameserver target addresses opportunistically.
The policy is described per dependency depth.</p>
<p>The number of values determines the maximum dependency depth that Unbound
will pursue in answering a query.
A value of -1 means to fetch all targets opportunistically for that
dependency depth.
A value of 0 means to fetch on demand only.
A positive value fetches that many targets opportunistically.</p>
<p>Enclose the list between quotes (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>) and put spaces between numbers.
Setting all zeroes, &quot;0 0 0 0 0&quot; gives behaviour closer to that of BIND 9,
while setting &quot;-1 -1 -1 -1 -1&quot; gives behaviour rumoured to be closer to
that of BIND 8.</p>
<p>Default:  &quot;3 2 1 0 0&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-harden-short-bufsize">
<dt>harden-short-bufsize: <em>&lt;yes or no&gt;</em></dt><dd><p>Very small EDNS buffer sizes from queries are ignored.</p>
<p>Default: on (as described in the standard)</p>
</dd>
</dl>
<dl id="unbound-conf-harden-large-queries">
<dt>harden-large-queries: <em>&lt;yes or no&gt;</em></dt><dd><p>Very large queries are ignored.
Default is off, since it is legal protocol wise to send these, and could be
necessary for operation if TSIG or EDNS payload is very large.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-harden-glue">
<dt>harden-glue: <em>&lt;yes or no&gt;</em></dt><dd><p>Will trust glue only if it is within the servers authority.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-harden-dnssec-stripped">
<dt>harden-dnssec-stripped: <em>&lt;yes or no&gt;</em></dt><dd><p>Require DNSSEC data for trust-anchored zones, if such data is absent, the
zone becomes bogus.
If turned off, and no DNSSEC data is received (or the DNSKEY data fails to
validate), then the zone is made insecure, this behaves like there is no
trust anchor.
You could turn this off if you are sometimes behind an intrusive firewall
(of some sort) that removes DNSSEC data from packets, or a zone changes
from signed to unsigned to badly signed often.
If turned off you run the risk of a downgrade attack that disables security
for a zone.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-harden-below-nxdomain">
<dt>harden-below-nxdomain: <em>&lt;yes or no&gt;</em></dt><dd><p>From <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8020.html"><strong>RFC 8020</strong></a> (with title &quot;NXDOMAIN: There Really Is Nothing
Underneath&quot;), returns NXDOMAIN to queries for a name below another name
that is already known to be NXDOMAIN.
DNSSEC mandates NOERROR for empty nonterminals, hence this is possible.
Very old software might return NXDOMAIN for empty nonterminals (that
usually happen for reverse IP address lookups), and thus may be
incompatible with this.
To try to avoid this only DNSSEC-secure NXDOMAINs are used, because the old
software does not have DNSSEC.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The NXDOMAIN must be secure, this means NSEC3 with optout is
insufficient.</p>
</div>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-harden-referral-path">
<dt>harden-referral-path: <em>&lt;yes or no&gt;</em></dt><dd><p>Harden the referral path by performing additional queries for
infrastructure data.
Validates the replies if trust anchors are configured and the zones are
signed.
This enforces DNSSEC validation on nameserver NS sets and the nameserver
addresses that are encountered on the referral path to the answer.
Default is off, because it burdens the authority servers, and it is not RFC
standard, and could lead to performance problems because of the extra query
load that is generated.
Experimental option.
If you enable it consider adding more numbers after the
<a class="reference internal" href="#unbound-conf-target-fetch-policy"><span class="std std-ref">target-fetch-policy:</span></a> to increase
the max depth that is checked to.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-harden-algo-downgrade">
<dt>harden-algo-downgrade: <em>&lt;yes or no&gt;</em></dt><dd><p>Harden against algorithm downgrade when multiple algorithms are advertised
in the DS record.
If no, allows the weakest algorithm to validate the zone.
Zone signers must produce zones that allow this feature to work, but
sometimes they do not, and turning this option off avoids that validation
failure.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-harden-unknown-additional">
<dt>harden-unknown-additional: <em>&lt;yes or no&gt;</em></dt><dd><p>Harden against unknown records in the authority section and additional
section.
If no, such records are copied from the upstream and presented to the
client together with the answer.
If yes, it could hamper future protocol developments that want to add
records.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-use-caps-for-id">
<dt>use-caps-for-id: <em>&lt;yes or no&gt;</em></dt><dd><p>Use 0x20-encoded random bits in the query to foil spoof attempts.
This perturbs the lowercase and uppercase of query names sent to authority
servers and checks if the reply still has the correct casing.
This feature is an experimental implementation of draft dns-0x20.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-caps-exempt">
<dt>caps-exempt: <em>&lt;domain&gt;</em></dt><dd><p>Exempt the domain so that it does not receive caps-for-id perturbed
queries.
For domains that do not support 0x20 and also fail with fallback because
they keep sending different answers, like some load balancers.
Can be given multiple times, for different domains.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-caps-whitelist">
<dt>caps-whitelist: <em>&lt;yes or no&gt;</em></dt><dd><p>Alternate syntax for <a class="reference internal" href="#unbound-conf-caps-exempt"><span class="std std-ref">caps-exempt:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-qname-minimisation">
<dt>qname-minimisation: <em>&lt;yes or no&gt;</em></dt><dd><p>Send minimum amount of information to upstream servers to enhance privacy.
Only send minimum required labels of the QNAME and set QTYPE to A when
possible.
Best effort approach; full QNAME and original QTYPE will be sent when
upstream replies with a RCODE other than NOERROR, except when receiving
NXDOMAIN from a DNSSEC signed zone.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-qname-minimisation-strict">
<dt>qname-minimisation-strict: <em>&lt;yes or no&gt;</em></dt><dd><p>QNAME minimisation in strict mode.
Do not fall-back to sending full QNAME to potentially broken nameservers.
A lot of domains will not be resolvable when this option in enabled.
Only use if you know what you are doing.
This option only has effect when
<a class="reference internal" href="#unbound-conf-qname-minimisation"><span class="std std-ref">qname-minimisation:</span></a> is enabled.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-aggressive-nsec">
<dt>aggressive-nsec: <em>&lt;yes or no&gt;</em></dt><dd><p>Aggressive NSEC uses the DNSSEC NSEC chain to synthesize NXDOMAIN and other
denials, using information from previous NXDOMAINs answers.
It helps to reduce the query rate towards targets that get a very high
nonexistent name lookup rate.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-private-address">
<dt>private-address: <em>&lt;IP address or subnet&gt;</em></dt><dd><p>Give IPv4 of IPv6 addresses or classless subnets.
These are addresses on your private network, and are not allowed to be
returned for public internet names.
Any occurrence of such addresses are removed from DNS answers.
Additionally, the DNSSEC validator may mark the answers bogus.
This protects against so-called DNS Rebinding, where a user browser is
turned into a network proxy, allowing remote access through the browser to
other parts of your private network.</p>
<p>Some names can be allowed to contain your private addresses, by default all
the <a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> that you configured is
allowed to, and you can specify additional names using
<a class="reference internal" href="#unbound-conf-private-domain"><span class="std std-ref">private-domain:</span></a>.
No private addresses are enabled by default.</p>
<p>We consider to enable this for the <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1918.html"><strong>RFC 1918</strong></a> private IP address space by
default in later releases.
That would enable private addresses for <code class="docutils literal notranslate"><span class="pre">10.0.0.0/8</span></code>, <code class="docutils literal notranslate"><span class="pre">172.16.0.0/12</span></code>,
<code class="docutils literal notranslate"><span class="pre">192.168.0.0/16</span></code>, <code class="docutils literal notranslate"><span class="pre">169.254.0.0/16</span></code>, <code class="docutils literal notranslate"><span class="pre">fd00::/8</span></code> and <code class="docutils literal notranslate"><span class="pre">fe80::/10</span></code>,
since the RFC standards say these addresses should not be visible on the
public internet.</p>
<p>Turning on <code class="docutils literal notranslate"><span class="pre">127.0.0.0/8</span></code> would hinder many spamblocklists as they use
that.
Adding <code class="docutils literal notranslate"><span class="pre">::ffff:0:0/96</span></code> stops IPv4-mapped IPv6 addresses from bypassing
the filter.</p>
</dd>
</dl>
<dl id="unbound-conf-private-domain">
<dt>private-domain: <em>&lt;domain name&gt;</em></dt><dd><p>Allow this domain, and all its subdomains to contain private addresses.
Give multiple times to allow multiple domain names to contain private
addresses.</p>
<p>Default: (none)</p>
</dd>
</dl>
<dl id="unbound-conf-unwanted-reply-threshold">
<dt>unwanted-reply-threshold: <em>&lt;number&gt;</em></dt><dd><p>If set, a total number of unwanted replies is kept track of in every
thread.
When it reaches the threshold, a defensive action is taken and a warning is
printed to the log.
The defensive action is to clear the rrset and message caches, hopefully
flushing away any poison.
A value of 10 million is suggested.</p>
<p>Default: 0 (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-do-not-query-address">
<dt>do-not-query-address: <em>&lt;IP address&gt;</em></dt><dd><p>Do not query the given IP address.
Can be IPv4 or IPv6.
Append /num to indicate a classless delegation netblock, for example like
<code class="docutils literal notranslate"><span class="pre">10.2.3.4/24</span></code> or <code class="docutils literal notranslate"><span class="pre">2001::11/64</span></code>.</p>
<p>Default: (none)</p>
</dd>
</dl>
<dl id="unbound-conf-do-not-query-localhost">
<dt>do-not-query-localhost: <em>&lt;yes or no&gt;</em></dt><dd><p>If yes, localhost is added to the
<a class="reference internal" href="#unbound-conf-do-not-query-address"><span class="std std-ref">do-not-query-address:</span></a> entries,
both IPv6 <code class="docutils literal notranslate"><span class="pre">::1</span></code> and IPv4 <code class="docutils literal notranslate"><span class="pre">127.0.0.1/8</span></code>.
If no, then localhost can be used to send queries to.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-prefetch">
<dt>prefetch: <em>&lt;yes or no&gt;</em></dt><dd><p>If yes, message cache elements are prefetched before they expire to keep
the cache up to date.
Turning it on gives about 10 percent more traffic and load on the machine,
but popular items do not expire from the cache.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-prefetch-key">
<dt>prefetch-key: <em>&lt;yes or no&gt;</em></dt><dd><p>If yes, fetch the DNSKEYs earlier in the validation process, when a DS
record is encountered.
This lowers the latency of requests.
It does use a little more CPU.
Also if the cache is set to 0, it is no use.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-deny-any">
<dt>deny-any: <em>&lt;yes or no&gt;</em></dt><dd><p>If yes, deny queries of type ANY with an empty response.
If disabled, Unbound responds with a short list of resource records if some
can be found in the cache and makes the upstream type ANY query if there
are none.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-rrset-roundrobin">
<dt>rrset-roundrobin: <em>&lt;yes or no&gt;</em></dt><dd><p>If yes, Unbound rotates RRSet order in response (the random number is taken
from the query ID, for speed and thread safety).</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-minimal-responses">
<dt>minimal-responses: <em>&lt;yes or no&gt;</em></dt><dd><p>If yes, Unbound does not insert authority/additional sections into response
messages when those sections are not required.
This reduces response size significantly, and may avoid TCP fallback for
some responses.
This may cause a slight speedup.</p>
<p>The default is yes, even though the DNS protocol RFCs mandate these
sections, and the additional content could be of use and save roundtrips
for clients.
Because they are not used, and the saved roundtrips are easier saved with
prefetch, whilst this is faster.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-disable-dnssec-lame-check">
<dt>disable-dnssec-lame-check: <em>&lt;yes or no&gt;</em></dt><dd><p>If true, disables the DNSSEC lameness check in the iterator.
This check sees if RRSIGs are present in the answer, when dnssec is
expected, and retries another authority if RRSIGs are unexpectedly missing.
The validator will insist in RRSIGs for DNSSEC signed domains regardless of
this setting, if a trust anchor is loaded.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-module-config">
<dt>module-config: <em>&quot;&lt;module names&gt;&quot;</em></dt><dd><p>Module configuration, a list of module names separated by spaces, surround
the string with quotes (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>).
The modules can be <code class="docutils literal notranslate"><span class="pre">respip</span></code>, <code class="docutils literal notranslate"><span class="pre">validator</span></code>, or <code class="docutils literal notranslate"><span class="pre">iterator</span></code> (and possibly
more, see below).</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The ordering of the modules is significant, the order decides the order
of processing.</p>
</div>
<p>Setting this to just &quot;iterator&quot; will result in a non-validating server.
Setting this to &quot;validator iterator&quot; will turn on DNSSEC validation.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>You must also set trust-anchors for validation to be useful.</p>
</div>
<p>Adding <code class="docutils literal notranslate"><span class="pre">respip</span></code> to the front will cause RPZ processing to be done on all
queries.</p>
<p>The default is &quot;validator iterator&quot;.</p>
<p>When the server is built with EDNS client subnet support the default is
&quot;subnetcache validator iterator&quot;.</p>
<p>Most modules that need to be listed here have to be listed at the beginning
of the line.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">subnetcache</span></code> module has to be listed just before the iterator.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">python</span></code> module can be listed in different places, it then processes
the output of the module it is just before.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dynlib</span></code> module can be listed pretty much anywhere, it is only a very
thin wrapper that allows dynamic libraries to run in its place.</p>
</dd>
</dl>
<dl id="unbound-conf-trust-anchor-file">
<dt>trust-anchor-file: <em>&lt;filename&gt;</em></dt><dd><p>File with trusted keys for validation.
Both DS and DNSKEY entries can appear in the file.
The format of the file is the standard DNS Zone file format.</p>
<p>Default: &quot;&quot; (no trust anchor file)</p>
</dd>
</dl>
<dl id="unbound-conf-auto-trust-anchor-file">
<dt>auto-trust-anchor-file: <em>&lt;filename&gt;</em></dt><dd><p>File with trust anchor for one zone, which is tracked with <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5011.html"><strong>RFC 5011</strong></a>
probes.
The probes are run several times per month, thus the machine must be online
frequently.
The initial file can be one with contents as described in
<a class="reference internal" href="#unbound-conf-trust-anchor-file"><span class="std std-ref">trust-anchor-file:</span></a>.
The file is written to when the anchor is updated, so the Unbound user must
have write permission.
Write permission to the file, but also to the directory it is in (to create
a temporary file, which is necessary to deal with filesystem full events),
it must also be inside the <a class="reference internal" href="#unbound-conf-chroot"><span class="std std-ref">chroot:</span></a> (if that is
used).</p>
<p>Default: &quot;&quot; (no auto trust anchor file)</p>
</dd>
</dl>
<dl id="unbound-conf-trust-anchor">
<dt>trust-anchor: <em>&quot;&lt;Resource Record&gt;&quot;</em></dt><dd><p>A DS or DNSKEY RR for a key to use for validation.
Multiple entries can be given to specify multiple trusted keys, in addition
to the <a class="reference internal" href="#unbound-conf-trust-anchor-file"><span class="std std-ref">trust-anchor-file:</span></a>.
The resource record is entered in the same format as <em>dig(1)</em> or <em>drill(1)</em>
prints them, the same format as in the zone file.
Has to be on a single line, with <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> around it.
A TTL can be specified for ease of cut and paste, but is ignored.
A class can be specified, but class IN is default.</p>
<p>Default: (none)</p>
</dd>
</dl>
<dl id="unbound-conf-trusted-keys-file">
<dt>trusted-keys-file: <em>&lt;filename&gt;</em></dt><dd><p>File with trusted keys for validation.
Specify more than one file with several entries, one file per entry.
Like <a class="reference internal" href="#unbound-conf-trust-anchor-file"><span class="std std-ref">trust-anchor-file:</span></a> but has a
different file format.
Format is BIND-9 style format, the <code class="docutils literal notranslate"><span class="pre">trusted-keys</span> <span class="pre">{</span> <span class="pre">name</span> <span class="pre">flag</span> <span class="pre">proto</span> <span class="pre">algo</span>
<span class="pre">&quot;key&quot;;</span> <span class="pre">};</span></code> clauses are read.
It is possible to use wildcards with this statement, the wildcard is
expanded on start and on reload.</p>
<p>Default: &quot;&quot; (no trusted keys file)</p>
</dd>
</dl>
<dl id="unbound-conf-trust-anchor-signaling">
<dt>trust-anchor-signaling: <em>&lt;yes or no&gt;</em></dt><dd><p>Send <span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8145.html"><strong>RFC 8145</strong></a> key tag query after trust anchor priming.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-root-key-sentinel">
<dt>root-key-sentinel: <em>&lt;yes or no&gt;</em></dt><dd><p>Root key trust anchor sentinel.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-domain-insecure">
<dt>domain-insecure: <em>&lt;domain name&gt;</em></dt><dd><p>Sets <em>&lt;domain name&gt;</em> to be insecure, DNSSEC chain of trust is ignored
towards the <em>&lt;domain name&gt;</em>.
So a trust anchor above the domain name can not make the domain secure with
a DS record, such a DS record is then ignored.
Can be given multiple times to specify multiple domains that are treated as
if unsigned.
If you set trust anchors for the domain they override this setting (and the
domain is secured).</p>
<p>This can be useful if you want to make sure a trust anchor for external
lookups does not affect an (unsigned) internal domain.
A DS record externally can create validation failures for that internal
domain.</p>
<p>Default: (none)</p>
</dd>
</dl>
<dl id="unbound-conf-val-override-date">
<dt>val-override-date: <em>&lt;rrsig-style date spec&gt;</em></dt><dd><div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Debugging feature!</p>
</div>
<p>If enabled by giving a RRSIG style date, that date is used for verifying
RRSIG inception and expiration dates, instead of the current date.
Do not set this unless you are debugging signature inception and
expiration.
The value -1 ignores the date altogether, useful for some special
applications.</p>
<p>Default: 0 (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-val-sig-skew-min">
<dt>val-sig-skew-min: <em>&lt;seconds&gt;</em></dt><dd><p>Minimum number of seconds of clock skew to apply to validated signatures.
A value of 10% of the signature lifetime (expiration - inception) is used,
capped by this setting.
Default is 3600 (1 hour) which allows for daylight savings differences.
Lower this value for more strict checking of short lived signatures.</p>
<p>Default: 3600 (1 hour)</p>
</dd>
</dl>
<dl id="unbound-conf-val-sig-skew-max">
<dt>val-sig-skew-max: <em>&lt;seconds&gt;</em></dt><dd><p>Maximum number of seconds of clock skew to apply to validated signatures.
A value of 10% of the signature lifetime (expiration - inception) is used,
capped by this setting.
Default is 86400 (24 hours) which allows for timezone setting problems in
stable domains.
Setting both min and max very low disables the clock skew allowances.
Setting both min and max very high makes the validator check the signature
timestamps less strictly.</p>
<p>Default: 86400 (24 hours)</p>
</dd>
</dl>
<dl id="unbound-conf-val-max-restart">
<dt>val-max-restart: <em>&lt;number&gt;</em></dt><dd><p>The maximum number the validator should restart validation with another
authority in case of failed validation.</p>
<p>Default: 5</p>
</dd>
</dl>
<dl id="unbound-conf-val-bogus-ttl">
<dt>val-bogus-ttl: <em>&lt;seconds&gt;</em></dt><dd><p>The time to live for bogus data.
This is data that has failed validation; due to invalid signatures or other
checks.
The TTL from that data cannot be trusted, and this value is used instead.
The time interval prevents repeated revalidation of bogus data.</p>
<p>Default: 60</p>
</dd>
</dl>
<dl id="unbound-conf-val-clean-additional">
<dt>val-clean-additional: <em>&lt;yes or no&gt;</em></dt><dd><p>Instruct the validator to remove data from the additional section of secure
messages that are not signed properly.
Messages that are insecure, bogus, indeterminate or unchecked are not
affected.
Use this setting to protect the users that rely on this validator for
authentication from potentially bad data in the additional section.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-val-log-level">
<dt>val-log-level: <em>&lt;number&gt;</em></dt><dd><p>Have the validator print validation failures to the log.
Regardless of the verbosity setting.</p>
<p>At 1, for every user query that fails a line is printed to the logs.
This way you can monitor what happens with validation.
Use a diagnosis tool, such as dig or drill, to find out why validation is
failing for these queries.</p>
<p>At 2, not only the query that failed is printed but also the reason why
Unbound thought it was wrong and which server sent the faulty data.</p>
<p>Default: 0 (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-val-permissive-mode">
<dt>val-permissive-mode: <em>&lt;yes or no&gt;</em></dt><dd><p>Instruct the validator to mark bogus messages as indeterminate.
The security checks are performed, but if the result is bogus (failed
security), the reply is not withheld from the client with SERVFAIL as
usual.
The client receives the bogus data.
For messages that are found to be secure the AD bit is set in replies.
Also logging is performed as for full validation.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-ignore-cd-flag">
<dt>ignore-cd-flag: <em>&lt;yes or no&gt;</em></dt><dd><p>Instruct Unbound to ignore the CD flag from clients and refuse to return
bogus answers to them.
Thus, the CD (Checking Disabled) flag does not disable checking any more.
This is useful if legacy (w2008) servers that set the CD flag but cannot
validate DNSSEC themselves are the clients, and then Unbound provides them
with DNSSEC protection.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-disable-edns-do">
<dt>disable-edns-do: <em>&lt;yes or no&gt;</em></dt><dd><p>Disable the EDNS DO flag in upstream requests.
It breaks DNSSEC validation for Unbound's clients.
This results in the upstream name servers to not include DNSSEC records in
their replies and could be helpful for devices that cannot handle DNSSEC
information.
When the option is enabled, clients that set the DO flag receive no EDNS
record in the response to indicate the lack of support to them.
If this option is enabled but Unbound is already configured for DNSSEC
validation (i.e., the validator module is enabled; default) this option is
implicitly turned off with a warning as to not break DNSSEC validation in
Unbound.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-serve-expired">
<dt>serve-expired: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, Unbound attempts to serve old responses from cache with a TTL
of <a class="reference internal" href="#unbound-conf-serve-expired-reply-ttl"><span class="std std-ref">serve-expired-reply-ttl:</span></a> in
the response without waiting for the actual resolution to finish.
The actual resolution answer ends up in the cache later on.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-serve-expired-ttl">
<dt>serve-expired-ttl: <em>&lt;seconds&gt;</em></dt><dd><p>Limit serving of expired responses to configured seconds after expiration.
0 disables the limit.
This option only applies when
<a class="reference internal" href="#unbound-conf-serve-expired"><span class="std std-ref">serve-expired:</span></a> is enabled.
A suggested value per <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8767.html"><strong>RFC 8767</strong></a> is between 86400 (1 day) and 259200 (3
days).</p>
<p>Default: 0</p>
</dd>
</dl>
<dl id="unbound-conf-serve-expired-ttl-reset">
<dt>serve-expired-ttl-reset: <em>&lt;yes or no&gt;</em></dt><dd><p>Set the TTL of expired records to the
<a class="reference internal" href="#unbound-conf-serve-expired-ttl"><span class="std std-ref">serve-expired-ttl:</span></a> value after a
failed attempt to retrieve the record from upstream.
This makes sure that the expired records will be served as long as there
are queries for it.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-serve-expired-reply-ttl">
<dt>serve-expired-reply-ttl: <em>&lt;seconds&gt;</em></dt><dd><p>TTL value to use when replying with expired data.
If
<a class="reference internal" href="#unbound-conf-serve-expired-client-timeout"><span class="std std-ref">serve-expired-client-timeout:</span></a>
is also used then it is RECOMMENDED to use 30 as the value (<span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8767.html"><strong>RFC 8767</strong></a>).</p>
<p>Default: 30</p>
</dd>
</dl>
<dl id="unbound-conf-serve-expired-client-timeout">
<dt>serve-expired-client-timeout: <em>&lt;msec&gt;</em></dt><dd><p>Time in milliseconds before replying to the client with expired data.
This essentially enables the serve-stale behavior as specified in
<span class="target" id="index-7"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8767.html"><strong>RFC 8767</strong></a> that first tries to resolve before immediately responding with
expired data.
A recommended value per <span class="target" id="index-8"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8767.html"><strong>RFC 8767</strong></a> is 1800.
Setting this to 0 will disable this behavior.</p>
<p>Default: 0</p>
</dd>
</dl>
<dl id="unbound-conf-serve-original-ttl">
<dt>serve-original-ttl: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, Unbound will always return the original TTL as received from
the upstream name server rather than the decrementing TTL as stored in the
cache.
This feature may be useful if Unbound serves as a front-end to a hidden
authoritative name server.</p>
<p>Enabling this feature does not impact cache expiry, it only changes the TTL
Unbound embeds in responses to queries.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Enabling this feature implicitly disables enforcement of the configured
minimum and maximum TTL, as it is assumed users who enable this feature
do not want Unbound to change the TTL obtained from an upstream server.</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The values set using <a class="reference internal" href="#unbound-conf-cache-min-ttl"><span class="std std-ref">cache-min-ttl:</span></a>
and <a class="reference internal" href="#unbound-conf-cache-max-ttl"><span class="std std-ref">cache-max-ttl:</span></a> are ignored.</p>
</div>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-val-nsec3-keysize-iterations">
<dt>val-nsec3-keysize-iterations: &lt;&quot;list of values&quot;&gt;</dt><dd><p>List of keysize and iteration count values, separated by spaces, surrounded
by quotes.
This determines the maximum allowed NSEC3 iteration count before a message
is simply marked insecure instead of performing the many hashing
iterations.
The list must be in ascending order and have at least one entry.
If you set it to &quot;1024 65535&quot; there is no restriction to NSEC3 iteration
values.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>This table must be kept short; a very long list could cause slower
operation.</p>
</div>
<p>Default: &quot;1024 150 2048 150 4096 150&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-zonemd-permissive-mode">
<dt>zonemd-permissive-mode: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled the ZONEMD verification failures are only logged and do not
cause the zone to be blocked and only return servfail.
Useful for testing out if it works, or if the operator only wants to be
notified of a problem without disrupting service.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-add-holddown">
<dt>add-holddown: <em>&lt;seconds&gt;</em></dt><dd><p>Instruct the
<a class="reference internal" href="#unbound-conf-auto-trust-anchor-file"><span class="std std-ref">auto-trust-anchor-file:</span></a> probe
mechanism for <span class="target" id="index-9"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5011.html"><strong>RFC 5011</strong></a> autotrust updates to add new trust anchors only
after they have been visible for this time.</p>
<p>Default: 2592000 (30 days as per the RFC)</p>
</dd>
</dl>
<dl id="unbound-conf-del-holddown">
<dt>del-holddown: <em>&lt;seconds&gt;</em></dt><dd><p>Instruct the
<a class="reference internal" href="#unbound-conf-auto-trust-anchor-file"><span class="std std-ref">auto-trust-anchor-file:</span></a> probe
mechanism for <span class="target" id="index-10"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5011.html"><strong>RFC 5011</strong></a> autotrust updates to remove revoked trust anchors
after they have been kept in the revoked list for this long.</p>
<p>Default: 2592000 (30 days as per the RFC)</p>
</dd>
</dl>
<dl id="unbound-conf-keep-missing">
<dt>keep-missing: <em>&lt;seconds&gt;</em></dt><dd><p>Instruct the
<a class="reference internal" href="#unbound-conf-auto-trust-anchor-file"><span class="std std-ref">auto-trust-anchor-file:</span></a> probe
mechanism for <span class="target" id="index-11"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5011.html"><strong>RFC 5011</strong></a> autotrust updates to remove missing trust anchors
after they have been unseen for this long.
This cleans up the state file if the target zone does not perform trust
anchor revocation, so this makes the auto probe mechanism work with zones
that perform regular (non-5011) rollovers.
The value 0 does not remove missing anchors, as per the RFC.</p>
<p>Default: 31622400 (366 days)</p>
</dd>
</dl>
<dl id="unbound-conf-permit-small-holddown">
<dt>permit-small-holddown: <em>&lt;yes or no&gt;</em></dt><dd><p>Debug option that allows the autotrust 5011 rollover timers to assume very
small values.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-key-cache-size">
<dt>key-cache-size: <em>&lt;number&gt;</em></dt><dd><p>Number of bytes size of the key cache.
A plain number is in bytes, append 'k', 'm' or 'g' for kilobytes, megabytes
or gigabytes (1024*1024 bytes in a megabyte).</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-key-cache-slabs">
<dt>key-cache-slabs: <em>&lt;number&gt;</em></dt><dd><p>Number of slabs in the key cache.
Slabs reduce lock contention by threads.
Must be set to a power of 2.
Setting (close) to the number of cpus is a reasonable guess.</p>
<p>Default: 4</p>
</dd>
</dl>
<dl id="unbound-conf-neg-cache-size">
<dt>neg-cache-size: <em>&lt;number&gt;</em></dt><dd><p>Number of bytes size of the aggressive negative cache.
A plain number is in bytes, append 'k', 'm' or 'g' for kilobytes, megabytes
or gigabytes (1024*1024 bytes in a megabyte).</p>
<p>Default: 1m</p>
</dd>
</dl>
<dl id="unbound-conf-unblock-lan-zones">
<dt>unblock-lan-zones: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, then for private address space, the reverse lookups are no
longer filtered.
This allows Unbound when running as dns service on a host where it provides
service for that host, to put out all of the queries for the 'lan'
upstream.
When enabled, only localhost, <code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code> reverse and <code class="docutils literal notranslate"><span class="pre">::1</span></code> reverse
zones are configured with default local zones.
Disable the option when Unbound is running as a (DHCP-) DNS network
resolver for a group of machines, where such lookups should be filtered
(RFC compliance), this also stops potential data leakage about the local
network to the upstream DNS servers.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-insecure-lan-zones">
<dt>insecure-lan-zones: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, then reverse lookups in private address space are not
validated.
This is usually required whenever
<a class="reference internal" href="#unbound-conf-unblock-lan-zones"><span class="std std-ref">unblock-lan-zones:</span></a> is used.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-local-zone">
<dt>local-zone: <em>&lt;zone&gt; &lt;type&gt;</em></dt><dd><p>Configure a local zone.
The type determines the answer to give if there is no match from
<a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a>.
The types are
<a class="reference internal" href="#unbound-conf-local-zone-type-deny"><span class="std std-ref">deny</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-refuse"><span class="std std-ref">refuse</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-static"><span class="std std-ref">static</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-transparent"><span class="std std-ref">transparent</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-redirect"><span class="std std-ref">redirect</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-nodefault"><span class="std std-ref">nodefault</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-typetransparent"><span class="std std-ref">typetransparent</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-inform"><span class="std std-ref">inform</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-inform-deny"><span class="std std-ref">inform_deny</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-inform-redirect"><span class="std std-ref">inform_redirect</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-always-transparent"><span class="std std-ref">always_transparent</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-block-a"><span class="std std-ref">block_a</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-always-refuse"><span class="std std-ref">always_refuse</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-always-nxdomain"><span class="std std-ref">always_nxdomain</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-always-null"><span class="std std-ref">always_null</span></a>,
<a class="reference internal" href="#unbound-conf-local-zone-type-noview"><span class="std std-ref">noview</span></a>,
and are explained below.
After that the default settings are listed.
Use <a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> to enter data into the
local zone.
Answers for local zones are authoritative DNS answers.
By default the zones are class IN.</p>
<p>If you need more complicated authoritative data, with referrals,
wildcards, CNAME/DNAME support, or DNSSEC authoritative service,
setup a <a class="reference internal" href="#unbound-conf-stub"><span class="std std-ref">stub-zone:</span></a> for it as detailed in the
stub zone section below.
A <a class="reference internal" href="#unbound-conf-stub"><span class="std std-ref">stub-zone:</span></a> can be used to have unbound
send queries to another server, an authoritative server, to fetch the
information.
With a <a class="reference internal" href="#unbound-conf-forward"><span class="std std-ref">forward-zone:</span></a>, unbound sends
queries to a server that is a recursive server to fetch the information.
With an <a class="reference internal" href="#unbound-conf-auth"><span class="std std-ref">auth-zone:</span></a> a zone can be loaded from
file and used, it can be used like a local zone for users downstream, or
the <a class="reference internal" href="#unbound-conf-auth"><span class="std std-ref">auth-zone:</span></a> information can be used to fetch
information from when resolving like it is an upstream server.
The <a class="reference internal" href="#unbound-conf-forward"><span class="std std-ref">forward-zone:</span></a> and
<a class="reference internal" href="#unbound-conf-auth"><span class="std std-ref">auth-zone:</span></a> options are described in their
sections below.
If you want to perform filtering of the information that the users can
fetch, the <a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> and
<a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> statements allow for this, but
also the <a class="reference internal" href="#unbound-conf-rpz"><span class="std std-ref">rpz:</span></a> functionality can be used, described
in the RPZ section.</p>
<dl class="simple" id="unbound-conf-local-zone-type-deny">
<dt>deny</dt><dd><p>Do not send an answer, drop the query.
If there is a match from local data, the query is answered.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-refuse">
<dt>refuse</dt><dd><p>Send an error message reply, with rcode REFUSED.
If there is a match from local data, the query is answered.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-static">
<dt>static</dt><dd><p>If there is a match from local data, the query is answered.
Otherwise, the query is answered with NODATA or NXDOMAIN.
For a negative answer a SOA is included in the answer if present as
<a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> for the zone apex domain.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-transparent">
<dt>transparent</dt><dd><p>If there is a match from <a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a>,
the query is answered.
Otherwise if the query has a different name, the query is resolved
normally.
If the query is for a name given in
<a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> but no such type of data is
given in localdata, then a NOERROR NODATA answer is returned.
If no <a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> is given
<a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> causes a transparent zone
to be created by default.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-typetransparent">
<dt>typetransparent</dt><dd><p>If there is a match from local data, the query is answered.
If the query is for a different name, or for the same name but for a
different type, the query is resolved normally.
So, similar to
<a class="reference internal" href="#unbound-conf-local-zone-type-transparent"><span class="std std-ref">transparent</span></a> but types
that are not listed in local data are resolved normally, so if an A
record is in the local data that does not cause a NODATA reply for AAAA
queries.</p>
</dd>
</dl>
<dl id="unbound-conf-local-zone-type-redirect">
<dt>redirect</dt><dd><p>The query is answered from the local data for the zone name.
There may be no local data beneath the zone name.
This answers queries for the zone, and all subdomains of the zone with
the local data for the zone.
It can be used to redirect a domain to return a different address
record to the end user, with</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-zone: &quot;example.com.&quot; redirect
local-data: &quot;example.com. A 127.0.0.1&quot;
</pre></div>
</div>
</div></blockquote>
<p>queries for <code class="docutils literal notranslate"><span class="pre">www.example.com</span></code> and <code class="docutils literal notranslate"><span class="pre">www.foo.example.com</span></code> are
redirected, so that users with web browsers cannot access sites with
suffix example.com.</p>
</dd>
</dl>
<dl id="unbound-conf-local-zone-type-inform">
<dt>inform</dt><dd><p>The query is answered normally, same as
<a class="reference internal" href="#unbound-conf-local-zone-type-transparent"><span class="std std-ref">transparent</span></a>.
The client IP address (&#64;portnumber) is printed to the logfile.
The log message is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>timestamp, unbound-pid, info: zonename inform IP@port queryname type class.
</pre></div>
</div>
<p>This option can be used for normal resolution, but machines looking up
infected names are logged, eg. to run antivirus on them.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-inform-deny">
<dt>inform_deny</dt><dd><p>The query is dropped, like
<a class="reference internal" href="#unbound-conf-local-zone-type-deny"><span class="std std-ref">deny</span></a>, and logged, like
<a class="reference internal" href="#unbound-conf-local-zone-type-inform"><span class="std std-ref">inform</span></a>.
Ie. find infected machines without answering the queries.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-inform-redirect">
<dt>inform_redirect</dt><dd><p>The query is redirected, like
<a class="reference internal" href="#unbound-conf-local-zone-type-redirect"><span class="std std-ref">redirect</span></a>, and logged,
like <a class="reference internal" href="#unbound-conf-local-zone-type-inform"><span class="std std-ref">inform</span></a>.
Ie. answer queries with fixed data and also log the machines that ask.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-always-transparent">
<dt>always_transparent</dt><dd><p>Like <a class="reference internal" href="#unbound-conf-local-zone-type-transparent"><span class="std std-ref">transparent</span></a>, but
ignores local data and resolves normally.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-block-a">
<dt>block_a</dt><dd><p>Like <a class="reference internal" href="#unbound-conf-local-zone-type-transparent"><span class="std std-ref">transparent</span></a>, but
ignores local data and resolves normally all query types excluding A.
For A queries it unconditionally returns NODATA.
Useful in cases when there is a need to explicitly force all apps to
use IPv6 protocol and avoid any queries to IPv4.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-always-refuse">
<dt>always_refuse</dt><dd><p>Like <a class="reference internal" href="#unbound-conf-local-zone-type-refuse"><span class="std std-ref">refuse</span></a>, but ignores
local data and refuses the query.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-always-nxdomain">
<dt>always_nxdomain</dt><dd><p>Like <a class="reference internal" href="#unbound-conf-local-zone-type-static"><span class="std std-ref">static</span></a>, but ignores
local data and returns NXDOMAIN for the query.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-always-nodata">
<dt>always_nodata</dt><dd><p>Like <a class="reference internal" href="#unbound-conf-local-zone-type-static"><span class="std std-ref">static</span></a>, but ignores
local data and returns NODATA for the query.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-always-deny">
<dt>always_deny</dt><dd><p>Like <a class="reference internal" href="#unbound-conf-local-zone-type-deny"><span class="std std-ref">deny</span></a>, but ignores local
data and drops the query.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-always-null">
<dt>always_null</dt><dd><p>Always returns <code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code> or <code class="docutils literal notranslate"><span class="pre">::0</span></code> for every name in the zone.
Like <a class="reference internal" href="#unbound-conf-local-zone-type-redirect"><span class="std std-ref">redirect</span></a> with zero
data for A and AAAA.
Ignores local data in the zone.
Used for some block lists.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-noview">
<dt>noview</dt><dd><p>Breaks out of that view and moves towards the global local zones for
answer to the query.
If the <a class="reference internal" href="#unbound-conf-view-view-first"><span class="std std-ref">view-first:</span></a> is no, it'll
resolve normally.
If <a class="reference internal" href="#unbound-conf-view-view-first"><span class="std std-ref">view-first:</span></a> is enabled, it'll
break perform that step and check the global answers.
For when the view has view specific overrides but some zone has to be
answered from global local zone contents.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-type-nodefault">
<dt>nodefault</dt><dd><p>Used to turn off default contents for AS112 zones.
The other types also turn off default contents for the zone.
The <a class="reference internal" href="#unbound-conf-local-zone-type-nodefault"><span class="std std-ref">nodefault</span></a> option has
no other effect than turning off default contents for the given zone.
Use <a class="reference internal" href="#unbound-conf-local-zone-type-nodefault"><span class="std std-ref">nodefault</span></a> if you use
exactly that zone, if you want to use a subzone, use
<a class="reference internal" href="#unbound-conf-local-zone-type-transparent"><span class="std std-ref">transparent</span></a>.</p>
</dd>
</dl>
<p>The default zones are localhost, reverse <code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code> and <code class="docutils literal notranslate"><span class="pre">::1</span></code>, the
home.arpa, onion, test, invalid and the AS112 zones.
The AS112 zones are reverse DNS zones for private use and reserved IP
addresses for which the servers on the internet cannot provide correct
answers.
They are configured by default to give NXDOMAIN (no reverse information)
answers.</p>
<p>The defaults can be turned off by specifying your own
<a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> of that name, or using the
<a class="reference internal" href="#unbound-conf-local-zone-type-nodefault"><span class="std std-ref">nodefault</span></a> type.
Below is a list of the default zone contents.</p>
<dl>
<dt>localhost</dt><dd><p>The IPv4 and IPv6 localhost information is given.
NS and SOA records are provided for completeness and to satisfy some
DNS update tools.
Default content:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-zone: &quot;localhost.&quot; redirect
local-data: &quot;localhost. 10800 IN NS localhost.&quot;
local-data: &quot;localhost. 10800 IN SOA localhost. nobody.invalid. 1 3600 1200 604800 10800&quot;
local-data: &quot;localhost. 10800 IN A 127.0.0.1&quot;
local-data: &quot;localhost. 10800 IN AAAA ::1&quot;
</pre></div>
</div>
</dd>
<dt>reverse IPv4 loopback</dt><dd><p>Default content:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-zone: &quot;127.in-addr.arpa.&quot; static
local-data: &quot;127.in-addr.arpa. 10800 IN NS localhost.&quot;
local-data: &quot;127.in-addr.arpa. 10800 IN SOA localhost. nobody.invalid. 1 3600 1200 604800 10800&quot;
local-data: &quot;1.0.0.127.in-addr.arpa. 10800 IN PTR localhost.&quot;
</pre></div>
</div>
</dd>
<dt>reverse IPv6 loopback</dt><dd><p>Default content:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-zone: &quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.&quot; static
local-data: &quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa. 10800 IN NS localhost.&quot;
local-data: &quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa. 10800 IN SOA localhost. nobody.invalid. 1 3600 1200 604800 10800&quot;
local-data: &quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa. 10800 IN PTR localhost.&quot;
</pre></div>
</div>
</dd>
<dt>home.arpa (<span class="target" id="index-12"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8375.html"><strong>RFC 8375</strong></a>)</dt><dd><p>Default content:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-zone: &quot;home.arpa.&quot; static
local-data: &quot;home.arpa. 10800 IN NS localhost.&quot;
local-data: &quot;home.arpa. 10800 IN SOA localhost. nobody.invalid. 1 3600 1200 604800 10800&quot;
</pre></div>
</div>
</dd>
<dt>onion (<span class="target" id="index-13"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7686.html"><strong>RFC 7686</strong></a>)</dt><dd><p>Default content:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-zone: &quot;onion.&quot; static
local-data: &quot;onion. 10800 IN NS localhost.&quot;
local-data: &quot;onion. 10800 IN SOA localhost. nobody.invalid. 1 3600 1200 604800 10800&quot;
</pre></div>
</div>
</dd>
<dt>test (<span class="target" id="index-14"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6761.html"><strong>RFC 6761</strong></a>)</dt><dd><p>Default content:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-zone: &quot;test.&quot; static
local-data: &quot;test. 10800 IN NS localhost.&quot;
local-data: &quot;test. 10800 IN SOA localhost. nobody.invalid. 1 3600 1200 604800 10800&quot;
</pre></div>
</div>
</dd>
<dt>invalid (<span class="target" id="index-15"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6761.html"><strong>RFC 6761</strong></a>)</dt><dd><p>Default content:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-zone: &quot;invalid.&quot; static
local-data: &quot;invalid. 10800 IN NS localhost.&quot;
local-data: &quot;invalid. 10800 IN SOA localhost. nobody.invalid. 1 3600 1200 604800 10800&quot;
</pre></div>
</div>
</dd>
<dt>reverse <span class="target" id="index-16"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1918.html"><strong>RFC 1918</strong></a> local use zones</dt><dd><p>Reverse data for zones <code class="docutils literal notranslate"><span class="pre">10.in-addr.arpa</span></code>, <code class="docutils literal notranslate"><span class="pre">16.172.in-addr.arpa</span></code> to
<code class="docutils literal notranslate"><span class="pre">31.172.in-addr.arpa</span></code>, <code class="docutils literal notranslate"><span class="pre">168.192.in-addr.arpa</span></code>.
The <a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> is set static and as
<a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> SOA and NS records are
provided.</p>
</dd>
<dt>reverse <span class="target" id="index-17"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3330.html"><strong>RFC 3330</strong></a> IP4 this, link-local, testnet and broadcast</dt><dd><p>Reverse data for zones <code class="docutils literal notranslate"><span class="pre">0.in-addr.arpa</span></code>, <code class="docutils literal notranslate"><span class="pre">254.169.in-addr.arpa</span></code>,
<code class="docutils literal notranslate"><span class="pre">2.0.192.in-addr.arpa</span></code> (TEST NET 1), <code class="docutils literal notranslate"><span class="pre">100.51.198.in-addr.arpa</span></code>
(TEST NET 2), <code class="docutils literal notranslate"><span class="pre">113.0.203.in-addr.arpa</span></code> (TEST NET 3),
<code class="docutils literal notranslate"><span class="pre">255.255.255.255.in-addr.arpa</span></code>.
And from <code class="docutils literal notranslate"><span class="pre">64.100.in-addr.arpa</span></code> to <code class="docutils literal notranslate"><span class="pre">127.100.in-addr.arpa</span></code> (Shared
Address Space).</p>
</dd>
<dt>reverse <span class="target" id="index-18"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a> IPv6 unspecified</dt><dd><p>Reverse data for zone
<code class="docutils literal notranslate"><span class="pre">0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.</span></code></p>
</dd>
<dt>reverse <span class="target" id="index-19"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4193.html"><strong>RFC 4193</strong></a> IPv6 Locally Assigned Local Addresses</dt><dd><p>Reverse data for zone <code class="docutils literal notranslate"><span class="pre">D.F.ip6.arpa</span></code>.</p>
</dd>
<dt>reverse <span class="target" id="index-20"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a> IPv6 Link Local Addresses</dt><dd><p>Reverse data for zones <code class="docutils literal notranslate"><span class="pre">8.E.F.ip6.arpa</span></code> to <code class="docutils literal notranslate"><span class="pre">B.E.F.ip6.arpa</span></code>.</p>
</dd>
<dt>reverse IPv6 Example Prefix</dt><dd><p>Reverse data for zone <code class="docutils literal notranslate"><span class="pre">8.B.D.0.1.0.0.2.ip6.arpa</span></code>.
This zone is used for tutorials and examples.
You can remove the block on this zone with:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-zone: 8.B.D.0.1.0.0.2.ip6.arpa. nodefault
</pre></div>
</div>
</dd>
</dl>
<p>You can also selectively unblock a part of the zone by making that part
transparent with a <a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> statement.
This also works with the other default zones.</p>
</dd>
</dl>
<dl id="unbound-conf-local-data">
<dt>local-data: <em>&quot;&lt;resource record string&gt;&quot;</em></dt><dd><p>Configure local data, which is served in reply to queries for it.
The query has to match exactly unless you configure the
<a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> as redirect.
If not matched exactly, the <a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a>
type determines further processing.
If <a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> is configured that is not a
subdomain of a <a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a>, a
<a class="reference internal" href="#unbound-conf-local-zone-type-transparent"><span class="std std-ref">transparent local-zone</span></a> is
configured.
For record types such as TXT, use single quotes, as in:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>local-data: &#39;example. TXT &quot;text&quot;&#39;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>If you need more complicated authoritative data, with referrals,
wildcards, CNAME/DNAME support, or DNSSEC authoritative service, setup
a <a class="reference internal" href="#unbound-conf-stub"><span class="std std-ref">stub-zone:</span></a> for it as detailed in the stub
zone section below.</p>
</div>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-data-ptr">
<dt>local-data-ptr: <em>&quot;IPaddr name&quot;</em></dt><dd><p>Configure local data shorthand for a PTR record with the reversed IPv4 or
IPv6 address and the host name.
For example <code class="docutils literal notranslate"><span class="pre">&quot;192.0.2.4</span> <span class="pre">www.example.com&quot;</span></code>.
TTL can be inserted like this: <code class="docutils literal notranslate"><span class="pre">&quot;2001:DB8::4</span> <span class="pre">7200</span> <span class="pre">www.example.com&quot;</span></code></p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-tag">
<dt>local-zone-tag: <em>&lt;zone&gt; &lt;&quot;list of tags&quot;&gt;</em></dt><dd><p>Assign tags to local zones.
Tagged localzones will only be applied when the used
<a class="reference internal" href="#unbound-conf-access-control"><span class="std std-ref">access-control:</span></a> element has a matching
tag.
Tags must be defined in <a class="reference internal" href="#unbound-conf-define-tag"><span class="std std-ref">define-tag:</span></a>.
Enclose list of tags in quotes (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>) and put spaces between tags.
When there are multiple tags it checks if the intersection of the list of
tags for the query and <a class="reference internal" href="#unbound-conf-local-zone-tag"><span class="std std-ref">local-zone-tag:</span></a>
is non-empty.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-local-zone-override">
<dt>local-zone-override: <em>&lt;zone&gt; &lt;IP netblock&gt; &lt;type&gt;</em></dt><dd><p>Override the local zone type for queries from addresses matching netblock.
Use this localzone type, regardless the type configured for the local zone
(both tagged and untagged) and regardless the type configured using
<a class="reference internal" href="#unbound-conf-access-control-tag-action"><span class="std std-ref">access-control-tag-action:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-response-ip">
<dt>response-ip: <em>&lt;IP-netblock&gt; &lt;action&gt;</em></dt><dd><p>This requires use of the <code class="docutils literal notranslate"><span class="pre">respip</span></code> module.</p>
<p>If the IP address in an AAAA or A RR in the answer section of a response
matches the specified IP netblock, the specified action will apply.
<em>&lt;action&gt;</em> has generally the same semantics as that for
<a class="reference internal" href="#unbound-conf-access-control-tag-action"><span class="std std-ref">access-control-tag-action:</span></a>,
but there are some exceptions.</p>
<p>Actions for <a class="reference internal" href="#unbound-conf-response-ip"><span class="std std-ref">response-ip:</span></a> are different
from those for <a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> in that in case
of the former there is no point of such conditions as &quot;the query matches it
but there is no local data&quot;.
Because of this difference, the semantics of
<a class="reference internal" href="#unbound-conf-response-ip"><span class="std std-ref">response-ip:</span></a> actions are modified or
simplified as follows: The <em>static</em>, <em>refuse</em>, <em>transparent</em>,
<em>typetransparent</em>, and <em>nodefault</em> actions are invalid for <em>response-ip</em>.
Using any of these will cause the configuration to be rejected as faulty.
The <em>deny</em> action is non-conditional, i.e. it always results in dropping
the corresponding query.
The resolution result before applying the <em>deny</em> action is still cached and
can be used for other queries.</p>
</dd>
</dl>
<dl id="unbound-conf-response-ip-data">
<dt>response-ip-data: <em>&lt;IP-netblock&gt; &lt;&quot;resource record string&quot;&gt;</em></dt><dd><p>This requires use of the <code class="docutils literal notranslate"><span class="pre">respip</span></code> module.</p>
<p>This specifies the action data for
<a class="reference internal" href="#unbound-conf-response-ip"><span class="std std-ref">response-ip:</span></a> with action being to redirect
as specified by <em>&lt;&quot;resource record string&quot;&gt;</em>.
<em>&lt;&quot;Resource record string&quot;&gt;</em> is similar to that of
<a class="reference internal" href="#unbound-conf-access-control-tag-action"><span class="std std-ref">access-control-tag-action:</span></a>,
but it must be of either AAAA, A or CNAME types.
If the <em>&lt;IP-netblock&gt;</em> is an IPv6/IPv4 prefix, the record must be AAAA/A
respectively, unless it is a CNAME (which can be used for both versions of
IP netblocks).
If it is CNAME there must not be more than one
<a class="reference internal" href="#unbound-conf-response-ip-data"><span class="std std-ref">response-ip-data:</span></a> for the same
<em>&lt;IP-netblock&gt;</em>.
Also, CNAME and other types of records must not coexist for the same
<em>&lt;IP-netblock&gt;</em>, following the normal rules for CNAME records.
The textual domain name for the CNAME does not have to be explicitly
terminated with a dot (<code class="docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code>); the root name is assumed to be the origin
for the name.</p>
</dd>
</dl>
<dl id="unbound-conf-response-ip-tag">
<dt>response-ip-tag: <em>&lt;IP-netblock&gt; &lt;&quot;list of tags&quot;&gt;</em></dt><dd><p>This requires use of the <code class="docutils literal notranslate"><span class="pre">respip</span></code> module.</p>
<p>Assign tags to response <em>&lt;IP-netblock&gt;</em>.
If the IP address in an AAAA or A RR in the answer section of a response
matches the specified <em>&lt;IP-netblock&gt;</em>, the specified tags are assigned to
the IP address.
Then, if an <a class="reference internal" href="#unbound-conf-access-control-tag"><span class="std std-ref">access-control-tag:</span></a> is
defined for the client and it includes one of the tags for the response IP,
the corresponding
<a class="reference internal" href="#unbound-conf-access-control-tag-action"><span class="std std-ref">access-control-tag-action:</span></a>
will apply.
Tag matching rule is the same as that for
<a class="reference internal" href="#unbound-conf-access-control-tag"><span class="std std-ref">access-control-tag:</span></a> and
<a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a>.
Unlike <a class="reference internal" href="#unbound-conf-local-zone-tag"><span class="std std-ref">local-zone-tag:</span></a>,
<a class="reference internal" href="#unbound-conf-response-ip-tag"><span class="std std-ref">response-ip-tag:</span></a> can be defined for an
<em>&lt;IP-netblock&gt;</em> even if no <a class="reference internal" href="#unbound-conf-response-ip"><span class="std std-ref">response-ip:</span></a> is
defined for that netblock.
If multiple <a class="reference internal" href="#unbound-conf-response-ip-tag"><span class="std std-ref">response-ip-tag:</span></a> options
are specified for the same <em>&lt;IP-netblock&gt;</em> in different statements, all but
the first will be ignored.
However, this will not be flagged as a configuration error, but the result
is probably not what was intended.</p>
<p>Actions specified in an
<a class="reference internal" href="#unbound-conf-access-control-tag-action"><span class="std std-ref">access-control-tag-action:</span></a>
that has a matching tag with
<a class="reference internal" href="#unbound-conf-response-ip-tag"><span class="std std-ref">response-ip-tag:</span></a> can be those that are
&quot;invalid&quot; for <a class="reference internal" href="#unbound-conf-response-ip"><span class="std std-ref">response-ip:</span></a> listed above,
since
<a class="reference internal" href="#unbound-conf-access-control-tag-action"><span class="std std-ref">access-control-tag-action:</span></a>
can be shared with local zones.
For these actions, if they behave differently depending on whether local
data exists or not in case of local zones, the behavior for
<a class="reference internal" href="#unbound-conf-response-ip-data"><span class="std std-ref">response-ip-data:</span></a> will generally
result in NOERROR/NODATA instead of NXDOMAIN, since the
<a class="reference internal" href="#unbound-conf-response-ip"><span class="std std-ref">response-ip:</span></a> data are inherently type
specific, and non-existence of data does not indicate anything about the
existence or non-existence of the qname itself.
For example, if the matching tag action is static but there is no data for
the corresponding <a class="reference internal" href="#unbound-conf-response-ip"><span class="std std-ref">response-ip:</span></a>
configuration, then the result will be NOERROR/NODATA.
The only case where NXDOMAIN is returned is when an
<a class="reference internal" href="#unbound-conf-local-zone-type-always-nxdomain"><span class="std std-ref">always_nxdomain</span></a>
action applies.</p>
</dd>
</dl>
<dl id="unbound-conf-ratelimit">
<dt>ratelimit: <em>&lt;number or 0&gt;</em></dt><dd><p>Enable ratelimiting of queries sent to nameserver for performing recursion.
0 disables the feature.
This option is experimental at this time.</p>
<p>The ratelimit is in queries per second that are allowed.
More queries are turned away with an error (SERVFAIL).
Cached responses are not ratelimited by this setting.</p>
<p>This stops recursive floods, eg. random query names, but not spoofed
reflection floods.
The zone of the query is determined by examining the nameservers for it,
the zone name is used to keep track of the rate.
For example, 1000 may be a suitable value to stop the server from being
overloaded with random names, and keeps unbound from sending traffic to the
nameservers for those zones.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Configured forwarders are excluded from ratelimiting.</p>
</div>
<p>Default: 0</p>
</dd>
</dl>
<dl id="unbound-conf-ratelimit-size">
<dt>ratelimit-size: <em>&lt;memory size&gt;</em></dt><dd><p>Give the size of the data structure in which the current ongoing rates are
kept track in.
In bytes or use m(mega), k(kilo), g(giga).
The ratelimit structure is small, so this data structure likely does not
need to be large.</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-ratelimit-slabs">
<dt>ratelimit-slabs: <em>&lt;number&gt;</em></dt><dd><p>Give power of 2 number of slabs, this is used to reduce lock contention in
the ratelimit tracking data structure.
Close to the number of CPUs is a fairly good setting.</p>
<p>Default: 4</p>
</dd>
</dl>
<dl id="unbound-conf-ratelimit-factor">
<dt>ratelimit-factor: <em>&lt;number&gt;</em></dt><dd><p>Set the amount of queries to rate limit when the limit is exceeded.
If set to 0, all queries are dropped for domains where the limit is
exceeded.
If set to another value, 1 in that number is allowed through to complete.
Default is 10, allowing 1/10 traffic to flow normally.
This can make ordinary queries complete (if repeatedly queried for), and
enter the cache, whilst also mitigating the traffic flow by the factor
given.</p>
<p>Default: 10</p>
</dd>
</dl>
<dl id="unbound-conf-ratelimit-backoff">
<dt>ratelimit-backoff: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, the ratelimit is treated as a hard failure instead of the
default maximum allowed constant rate.
When the limit is reached, traffic is ratelimited and demand continues to
be kept track of for a 2 second rate window.
No traffic is allowed, except for
<a class="reference internal" href="#unbound-conf-ratelimit-factor"><span class="std std-ref">ratelimit-factor:</span></a>, until demand
decreases below the configured ratelimit for a 2 second rate window.
Useful to set <a class="reference internal" href="#unbound-conf-ratelimit"><span class="std std-ref">ratelimit:</span></a> to a suspicious
rate to aggressively limit unusually high traffic.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ratelimit-for-domain">
<dt>ratelimit-for-domain: <em>&lt;domain&gt; &lt;number qps or 0&gt;</em></dt><dd><p>Override the global <a class="reference internal" href="#unbound-conf-ratelimit"><span class="std std-ref">ratelimit:</span></a> for an exact
match domain name with the listed number.
You can give this for any number of names.
For example, for a top-level-domain you may want to have a higher limit
than other names.
A value of 0 will disable ratelimiting for that domain.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ratelimit-below-domain">
<dt>ratelimit-below-domain: <em>&lt;domain&gt; &lt;number qps or 0&gt;</em></dt><dd><p>Override the global <a class="reference internal" href="#unbound-conf-ratelimit"><span class="std std-ref">ratelimit:</span></a> for a domain
name that ends in this name.
You can give this multiple times, it then describes different settings in
different parts of the namespace.
The closest matching suffix is used to determine the qps limit.
The rate for the exact matching domain name is not changed, use
<a class="reference internal" href="#unbound-conf-ratelimit-for-domain"><span class="std std-ref">ratelimit-for-domain:</span></a> to set
that, you might want to use different settings for a top-level-domain and
subdomains.
A value of 0 will disable ratelimiting for domain names that end in this
name.</p>
</dd>
</dl>
<dl id="unbound-conf-ip-ratelimit">
<dt>ip-ratelimit: <em>&lt;number or 0&gt;</em></dt><dd><p>Enable global ratelimiting of queries accepted per ip address.
This option is experimental at this time.
The ratelimit is in queries per second that are allowed.
More queries are completely dropped and will not receive a reply, SERVFAIL
or otherwise.
IP ratelimiting happens before looking in the cache.
This may be useful for mitigating amplification attacks.</p>
<p>Default: 0 (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-ip-ratelimit-cookie">
<dt>ip-ratelimit-cookie: <em>&lt;number or 0&gt;</em></dt><dd><p>Enable global ratelimiting of queries accepted per IP address with a valid
DNS Cookie.
This option is experimental at this time.
The ratelimit is in queries per second that are allowed.
More queries are completely dropped and will not receive a reply, SERVFAIL
or otherwise.
IP ratelimiting happens before looking in the cache.
This option could be useful in combination with
<a class="reference internal" href="#unbound-conf-access-control-action-allow-cookie"><span class="std std-ref">allow_cookie</span></a>, in an
attempt to mitigate other amplification attacks than UDP reflections (e.g.,
attacks targeting Unbound itself) which are already handled with DNS
Cookies.
If used, the value is suggested to be higher than
<a class="reference internal" href="#unbound-conf-ip-ratelimit"><span class="std std-ref">ip-ratelimit:</span></a> e.g., tenfold.</p>
<p>Default: 0 (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-ip-ratelimit-size">
<dt>ip-ratelimit-size: <em>&lt;memory size&gt;</em></dt><dd><p>Give the size of the data structure in which the current ongoing rates are
kept track in.
In bytes or use m(mega), k(kilo), g(giga).
The IP ratelimit structure is small, so this data structure likely does not
need to be large.</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-ip-ratelimit-slabs">
<dt>ip-ratelimit-slabs: <em>&lt;number&gt;</em></dt><dd><p>Give power of 2 number of slabs, this is used to reduce lock contention in
the IP ratelimit tracking data structure.
Close to the number of cpus is a fairly good setting.</p>
<p>Default: 4</p>
</dd>
</dl>
<dl id="unbound-conf-ip-ratelimit-factor">
<dt>ip-ratelimit-factor: <em>&lt;number&gt;</em></dt><dd><p>Set the amount of queries to rate limit when the limit is exceeded.
If set to 0, all queries are dropped for addresses where the limit is
exceeded.
If set to another value, 1 in that number is allowed through to complete.
Default is 10, allowing 1/10 traffic to flow normally.
This can make ordinary queries complete (if repeatedly queried for), and
enter the cache, whilst also mitigating the traffic flow by the factor
given.</p>
<p>Default: 10</p>
</dd>
</dl>
<dl id="unbound-conf-ip-ratelimit-backoff">
<dt>ip-ratelimit-backoff: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, the rate limit is treated as a hard failure instead of the
default maximum allowed constant rate.
When the limit is reached, traffic is ratelimited and demand continues to
be kept track of for a 2 second rate window.
No traffic is allowed, except for
<a class="reference internal" href="#unbound-conf-ip-ratelimit-factor"><span class="std std-ref">ip-ratelimit-factor:</span></a>, until demand
decreases below the configured ratelimit for a 2 second rate window.
Useful to set <a class="reference internal" href="#unbound-conf-ip-ratelimit"><span class="std std-ref">ip-ratelimit:</span></a> to a
suspicious rate to aggressively limit unusually high traffic.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-outbound-msg-retry">
<dt>outbound-msg-retry: <em>&lt;number&gt;</em></dt><dd><p>The number of retries, per upstream nameserver in a delegation, that
Unbound will attempt in case a throwaway response is received.
No response (timeout) contributes to the retry counter.
If a forward/stub zone is used, this is the number of retries per
nameserver in the zone.</p>
<p>Default: 5</p>
</dd>
</dl>
<dl id="unbound-conf-max-sent-count">
<dt>max-sent-count: <em>&lt;number&gt;</em></dt><dd><p>Hard limit on the number of outgoing queries Unbound will make while
resolving a name, making sure large NS sets do not loop.
Results in SERVFAIL when reached.
It resets on query restarts (e.g., CNAME) and referrals.</p>
<p>Default: 32</p>
</dd>
</dl>
<dl id="unbound-conf-max-query-restarts">
<dt>max-query-restarts: <em>&lt;number&gt;</em></dt><dd><p>Hard limit on the number of times Unbound is allowed to restart a query
upon encountering a CNAME record.
Results in SERVFAIL when reached.
Changing this value needs caution as it can allow long CNAME chains to be
accepted, where Unbound needs to verify (resolve) each link individually.</p>
<p>Default: 11</p>
</dd>
</dl>
<dl id="unbound-conf-fast-server-permil">
<dt>fast-server-permil: <em>&lt;number&gt;</em></dt><dd><p>Specify how many times out of 1000 to pick from the set of fastest servers.
0 turns the feature off.
A value of 900 would pick from the fastest servers 90 percent of the time,
and would perform normal exploration of random servers for the remaining
time.
When <a class="reference internal" href="#unbound-conf-prefetch"><span class="std std-ref">prefetch:</span></a> is enabled (or
<a class="reference internal" href="#unbound-conf-serve-expired"><span class="std std-ref">serve-expired:</span></a>), such prefetches are not
sped up, because there is no one waiting for it, and it presents a good
moment to perform server exploration.
The <a class="reference internal" href="#unbound-conf-fast-server-num"><span class="std std-ref">fast-server-num:</span></a> option can be
used to specify the size of the fastest servers set.</p>
<p>Default: 0</p>
</dd>
</dl>
<dl id="unbound-conf-fast-server-num">
<dt>fast-server-num: <em>&lt;number&gt;</em></dt><dd><p>Set the number of servers that should be used for fast server selection.
Only use the fastest specified number of servers with the
<a class="reference internal" href="#unbound-conf-fast-server-permil"><span class="std std-ref">fast-server-permil:</span></a> option, that
turns this on or off.</p>
<p>Default: 3</p>
</dd>
</dl>
<dl id="unbound-conf-answer-cookie">
<dt>answer-cookie: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, Unbound will answer to requests containing DNS Cookies as
specified in RFC 7873 and RFC 9018.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-cookie-secret">
<dt>cookie-secret: <em>&quot;&lt;128 bit hex string&gt;&quot;</em></dt><dd><p>Server's secret for DNS Cookie generation.
Useful to explicitly set for servers in an anycast deployment that need to
share the secret in order to verify each other's Server Cookies.
An example hex string would be &quot;000102030405060708090a0b0c0d0e0f&quot;.</p>
<p>Default: 128 bits random secret generated at startup time</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-edns-client-string">
<dt>edns-client-string: <em>&lt;IP netblock&gt; &lt;string&gt;</em></dt><dd><p>Include an EDNS0 option containing configured ASCII string in queries with
destination address matching the configured <em>&lt;IP netblock&gt;</em>.
This configuration option can be used multiple times.
The most specific match will be used.</p>
</dd>
</dl>
<dl id="unbound-conf-edns-client-string-opcode">
<dt>edns-client-string-opcode: <em>&lt;opcode&gt;</em></dt><dd><p>EDNS0 option code for the
<a class="reference internal" href="#unbound-conf-edns-client-string"><span class="std std-ref">edns-client-string:</span></a> option, from 0
to 65535.
A value from the 'Reserved for Local/Experimental' range (65001-65534)
should be used.</p>
<p>Default: 65001</p>
</dd>
</dl>
<dl id="unbound-conf-ede">
<dt>ede: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, Unbound will respond with Extended DNS Error codes
(<span class="target" id="index-21"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8914.html"><strong>RFC 8914</strong></a>).
These EDEs attach informative error messages to a response for various
errors.</p>
<p>When the <a class="reference internal" href="#unbound-conf-val-log-level"><span class="std std-ref">val-log-level:</span></a> option is also
set to 2, responses with Extended DNS Errors concerning DNSSEC failures
that are not served from cache, will also contain a descriptive text
message about the reason for the failure.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-ede-serve-expired">
<dt>ede-serve-expired: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, Unbound will attach an Extended DNS Error (<span class="target" id="index-22"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8914.html"><strong>RFC 8914</strong></a>) <em>Code 3
- Stale Answer</em> as EDNS0 option to the expired response.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>This will not attach the EDE code without setting
<a class="reference internal" href="#unbound-conf-ede"><span class="std std-ref">ede: yes</span></a> as well.</p>
</div>
<p>Default: no</p>
</dd>
</dl>
</section>
<section id="remote-control-options">
<span id="unbound-conf-remote"></span><h3>Remote Control Options<a class="headerlink" href="#remote-control-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>In the <strong>remote-control:</strong> clause are the declarations for the remote control
facility.
If this is enabled, the <a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a>
utility can be used to send commands to the running Unbound server.
The server uses these clauses to setup TLSv1 security for the connection.
The <a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a> utility also reads the
<strong>remote-control:</strong> section for options.
To setup the correct self-signed certificates use the
<em>unbound-control-setup(8)</em> utility.</p>
<dl id="unbound-conf-remote-control-enable">
<dt>control-enable: <em>&lt;yes or no&gt;</em></dt><dd><p>The option is used to enable remote control.
If turned off, the server does not listen for control commands.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-remote-control-interface">
<dt>control-interface: <em>&lt;IP address or interface name or path&gt;</em></dt><dd><p>Give IPv4 or IPv6 addresses or local socket path to listen on for control
commands.
If an interface name is used instead of an IP address, the list of IP
addresses on that interface are used.</p>
<p>By default localhost (<code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code> and <code class="docutils literal notranslate"><span class="pre">::1</span></code>) is listened to.
Use <code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code> and <code class="docutils literal notranslate"><span class="pre">::0</span></code> to listen to all interfaces.
If you change this and permissions have been dropped, you must restart the
server for the change to take effect.</p>
<p>If you set it to an absolute path, a unix domain socket is used.
This socket does not use the certificates and keys, so those files need not
be present.
To restrict access, Unbound sets permissions on the file to the user and
group that is configured, the access bits are set to allow the group
members to access the control socket file.
Put users that need to access the socket in the that group.
To restrict access further, create a directory to put the control socket in
and restrict access to that directory.</p>
</dd>
</dl>
<dl id="unbound-conf-remote-control-port">
<dt>control-port: <em>&lt;port number&gt;</em></dt><dd><p>The port number to listen on for IPv4 or IPv6 control interfaces.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>If you change this and permissions have been dropped, you must restart
the server for the change to take effect.</p>
</div>
<p>Default: 8953</p>
</dd>
</dl>
<dl id="unbound-conf-remote-control-use-cert">
<dt>control-use-cert: <em>&lt;yes or no&gt;</em></dt><dd><p>For localhost
<a class="reference internal" href="#unbound-conf-remote-control-interface"><span class="std std-ref">control-interface:</span></a> you can
disable the use of TLS by setting this option to &quot;no&quot;.
For local sockets, TLS is disabled and the value of this option is ignored.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-remote-server-key-file">
<dt>server-key-file: <em>&lt;private key file&gt;</em></dt><dd><p>Path to the server private key.
This file is generated by the
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control-setup(8)</span></a> utility.
This file is used by the Unbound server, but not by
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a>.</p>
<p>Default: unbound_server.key</p>
</dd>
</dl>
<dl id="unbound-conf-remote-server-cert-file">
<dt>server-cert-file: <em>&lt;certificate file.pem&gt;</em></dt><dd><p>Path to the server self signed certificate.
This file is generated by the
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control-setup(8)</span></a> utility.
This file is used by the Unbound server, and also by
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a>.</p>
<p>Default: unbound_server.pem</p>
</dd>
</dl>
<dl id="unbound-conf-remote-control-key-file">
<dt>control-key-file: <em>&lt;private key file&gt;</em></dt><dd><p>Path to the control client private key.
This file is generated by the
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control-setup(8)</span></a> utility.
This file is used by <a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a>.</p>
<p>Default: unbound_control.key</p>
</dd>
</dl>
<dl id="unbound-conf-remote-control-cert-file">
<dt>control-cert-file: <em>&lt;certificate file.pem&gt;</em></dt><dd><p>Path to the control client certificate.
This certificate has to be signed with the server certificate.
This file is generated by the
<a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control-setup(8)</span></a> utility.
This file is used by <a class="reference internal" href="unbound-control.html"><span class="doc">unbound-control(8)</span></a>.</p>
<p>Default: unbound_control.pem</p>
</dd>
</dl>
</section>
<section id="stub-zone-options">
<span id="unbound-conf-stub"></span><h3>Stub Zone Options<a class="headerlink" href="#stub-zone-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>There may be multiple <strong>stub-zone:</strong> clauses.
Each with a <a class="reference internal" href="#unbound-conf-stub-name"><span class="std std-ref">name:</span></a> and zero or more hostnames or
IP addresses.
For the stub zone this list of nameservers is used.
Class IN is assumed.
The servers should be authority servers, not recursors; Unbound performs the
recursive processing itself for stub zones.</p>
<p>The stub zone can be used to configure authoritative data to be used by the
resolver that cannot be accessed using the public internet servers.
This is useful for company-local data or private zones.
Setup an authoritative server on a different host (or different port).
Enter a config entry for Unbound with:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>stub-addr: &lt;ip address of host[@port]&gt;
</pre></div>
</div>
<p>The Unbound resolver can then access the data, without referring to the public
internet for it.</p>
<p>This setup allows DNSSEC signed zones to be served by that authoritative
server, in which case a trusted key entry with the public key can be put in
config, so that Unbound can validate the data and set the AD bit on replies for
the private zone (authoritative servers do not set the AD bit).
This setup makes Unbound capable of answering queries for the private zone, and
can even set the AD bit ('authentic'), but the AA ('authoritative') bit is not
set on these replies.</p>
<p>Consider adding <a class="reference internal" href="#unbound-conf-server"><span class="std std-ref">server:</span></a> statements for
<a class="reference internal" href="#unbound-conf-domain-insecure"><span class="std std-ref">domain-insecure:</span></a> and for
<a class="reference internal" href="#unbound-conf-local-zone-type-nodefault"><span class="std std-ref">local-zone: &lt;name&gt; nodefault</span></a>
for the zone if it is a locally served zone.
The insecure clause stops DNSSEC from invalidating the zone.
The <a class="reference internal" href="#unbound-conf-local-zone-type-nodefault"><span class="std std-ref">local-zone: nodefault</span></a> (or
<a class="reference internal" href="#unbound-conf-local-zone-type-transparent"><span class="std std-ref">transparent</span></a>) clause makes the
(reverse-) zone bypass Unbound's filtering of <span class="target" id="index-23"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1918.html"><strong>RFC 1918</strong></a> zones.</p>
<dl class="simple" id="unbound-conf-stub-name">
<dt>name: <em>&lt;domain name&gt;</em></dt><dd><p>Name of the stub zone.
This is the full domain name of the zone.</p>
</dd>
</dl>
<dl id="unbound-conf-stub-stub-host">
<dt>stub-host: <em>&lt;domain name&gt;</em></dt><dd><p>Name of stub zone nameserver.
Is itself resolved before it is used.</p>
<p>To use a non-default port for DNS communication append <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> with the
port number.</p>
<p>If TLS is enabled, then you can append a <code class="docutils literal notranslate"><span class="pre">'#'</span></code> and a name, then it'll
check the TLS authentication certificates with that name.</p>
<p>If you combine the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> and <code class="docutils literal notranslate"><span class="pre">'#'</span></code>, the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> comes first.
If only <code class="docutils literal notranslate"><span class="pre">'#'</span></code> is used the default port is the configured
<a class="reference internal" href="#unbound-conf-tls-port"><span class="std std-ref">tls-port:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-stub-stub-addr">
<dt>stub-addr: <em>&lt;IP address&gt;</em></dt><dd><p>IP address of stub zone nameserver.
Can be IPv4 or IPv6.</p>
<p>To use a non-default port for DNS communication append <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> with the
port number.</p>
<p>If TLS is enabled, then you can append a <code class="docutils literal notranslate"><span class="pre">'#'</span></code> and a name, then it'll
check the tls authentication certificates with that name.</p>
<p>If you combine the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> and <code class="docutils literal notranslate"><span class="pre">'#'</span></code>, the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> comes first.
If only <code class="docutils literal notranslate"><span class="pre">'#'</span></code> is used the default port is the configured
<a class="reference internal" href="#unbound-conf-tls-port"><span class="std std-ref">tls-port:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-stub-stub-prime">
<dt>stub-prime: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled it performs NS set priming, which is similar to root hints,
where it starts using the list of nameservers currently published by the
zone.
Thus, if the hint list is slightly outdated, the resolver picks up a
correct list online.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-stub-stub-first">
<dt>stub-first: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, a query is attempted without the stub clause if it fails.
The data could not be retrieved and would have caused SERVFAIL because the
servers are unreachable, instead it is tried without this clause.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-stub-stub-tls-upstream">
<dt>stub-tls-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>Enabled or disable whether the queries to this stub use TLS for transport.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-stub-stub-ssl-upstream">
<dt>stub-ssl-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>Alternate syntax for
<a class="reference internal" href="#unbound-conf-stub-stub-tls-upstream"><span class="std std-ref">stub-tls-upstream:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-stub-stub-tcp-upstream">
<dt>stub-tcp-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>If it is set to &quot;yes&quot; then upstream queries use TCP only for transport
regardless of global flag <a class="reference internal" href="#unbound-conf-tcp-upstream"><span class="std std-ref">tcp-upstream:</span></a>.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-stub-stub-no-cache">
<dt>stub-no-cache: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, data inside the stub is not cached.
This is useful when you want immediate changes to be visible.</p>
<p>Default: no</p>
</dd>
</dl>
</section>
<section id="forward-zone-options">
<span id="unbound-conf-forward"></span><h3>Forward Zone Options<a class="headerlink" href="#forward-zone-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>There may be multiple <strong>forward-zone:</strong> clauses.
Each with a <a class="reference internal" href="#unbound-conf-forward-name"><span class="std std-ref">name:</span></a> and zero or more hostnames
or IP addresses.
For the forward zone this list of nameservers is used to forward the queries
to.
The servers listed as <a class="reference internal" href="#unbound-conf-forward-forward-host"><span class="std std-ref">forward-host:</span></a>
and <a class="reference internal" href="#unbound-conf-forward-forward-addr"><span class="std std-ref">forward-addr:</span></a> have to handle
further recursion for the query.
Thus, those servers are not authority servers, but are (just like Unbound is)
recursive servers too; Unbound does not perform recursion itself for the
forward zone, it lets the remote server do it.
Class IN is assumed.
CNAMEs are chased by Unbound itself, asking the remote server for every name in
the indirection chain, to protect the local cache from illegal indirect
referenced items.
A <a class="reference internal" href="#unbound-conf-forward"><span class="std std-ref">forward-zone:</span></a> entry with name
<code class="docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code> and a <a class="reference internal" href="#unbound-conf-forward-forward-addr"><span class="std std-ref">forward-addr:</span></a> target
will forward all queries to that other server (unless it can answer from the
cache).</p>
<dl class="simple" id="unbound-conf-forward-name">
<dt>name: <em>&lt;domain name&gt;</em></dt><dd><p>Name of the forward zone.
This is the full domain name of the zone.</p>
</dd>
</dl>
<dl id="unbound-conf-forward-forward-host">
<dt>forward-host: <em>&lt;domain name&gt;</em></dt><dd><p>Name of server to forward to.
Is itself resolved before it is used.</p>
<p>To use a non-default port for DNS communication append <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> with the
port number.</p>
<p>If TLS is enabled, then you can append a <code class="docutils literal notranslate"><span class="pre">'#'</span></code> and a name, then it'll
check the TLS authentication certificates with that name.</p>
<p>If you combine the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> and <code class="docutils literal notranslate"><span class="pre">'#'</span></code>, the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> comes first.
If only <code class="docutils literal notranslate"><span class="pre">'#'</span></code> is used the default port is the configured
<a class="reference internal" href="#unbound-conf-tls-port"><span class="std std-ref">tls-port:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-forward-forward-addr">
<dt>forward-addr: <em>&lt;IP address&gt;</em></dt><dd><p>IP address of server to forward to.
Can be IPv4 or IPv6.</p>
<p>To use a non-default port for DNS communication append <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> with the
port number.</p>
<p>If TLS is enabled, then you can append a <code class="docutils literal notranslate"><span class="pre">'#'</span></code> and a name, then it'll
check the tls authentication certificates with that name.</p>
<p>If you combine the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> and <code class="docutils literal notranslate"><span class="pre">'#'</span></code>, the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> comes first.
If only <code class="docutils literal notranslate"><span class="pre">'#'</span></code> is used the default port is the configured
<a class="reference internal" href="#unbound-conf-tls-port"><span class="std std-ref">tls-port:</span></a>.</p>
<p>At high verbosity it logs the TLS certificate, with TLS enabled.
If you leave out the <code class="docutils literal notranslate"><span class="pre">'#'</span></code> and auth name from the
<a class="reference internal" href="#unbound-conf-forward-forward-addr"><span class="std std-ref">forward-addr:</span></a>, any name is
accepted.
The cert must also match a CA from the
<a class="reference internal" href="#unbound-conf-tls-cert-bundle"><span class="std std-ref">tls-cert-bundle:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-forward-forward-first">
<dt>forward-first: <em>&lt;yes or no&gt;</em></dt><dd><p>If a forwarded query is met with a SERVFAIL error, and this option is
enabled, Unbound will fall back to normal recursive resolution for this
query as if no query forwarding had been specified.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-forward-forward-tls-upstream">
<dt>forward-tls-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>Enabled or disable whether the queries to this forwarder use TLS for
transport.
If you enable this, also configure a
<a class="reference internal" href="#unbound-conf-tls-cert-bundle"><span class="std std-ref">tls-cert-bundle:</span></a> or use
<a class="reference internal" href="#unbound-conf-tls-win-cert"><span class="std std-ref">tls-win-cert:</span></a> to load CA certs, otherwise
the connections cannot be authenticated.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-forward-forward-ssl-upstream">
<dt>forward-ssl-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>Alternate syntax for
<a class="reference internal" href="#unbound-conf-forward-forward-tls-upstream"><span class="std std-ref">forward-tls-upstream:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-forward-forward-tcp-upstream">
<dt>forward-tcp-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>If it is set to &quot;yes&quot; then upstream queries use TCP only for transport
regardless of global flag <a class="reference internal" href="#unbound-conf-tcp-upstream"><span class="std std-ref">tcp-upstream:</span></a>.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-forward-forward-no-cache">
<dt>forward-no-cache: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, data inside the forward is not cached.
This is useful when you want immediate changes to be visible.</p>
<p>Default: no</p>
</dd>
</dl>
</section>
<section id="authority-zone-options">
<span id="unbound-conf-auth"></span><h3>Authority Zone Options<a class="headerlink" href="#authority-zone-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>Authority zones are configured with <strong>auth-zone:</strong>, and each one must have a
<a class="reference internal" href="#unbound-conf-auth-name"><span class="std std-ref">name:</span></a>.
There can be multiple ones, by listing multiple auth-zone clauses, each with a
different name, pertaining to that part of the namespace.
The authority zone with the name closest to the name looked up is used.
Authority zones can be processed on two distinct, non-exclusive, configurable
stages.</p>
<p>With <a class="reference internal" href="#unbound-conf-auth-for-downstream"><span class="std std-ref">for-downstream: yes</span></a> (default),
authority zones are processed after <strong>local-zones</strong> and before cache.
When used in this manner, Unbound responds like an authority server with no
further processing other than returning an answer from the zone contents.
A notable example, in this case, is CNAME records which are returned verbatim
to downstream clients without further resolution.</p>
<p>With <a class="reference internal" href="#unbound-conf-auth-for-upstream"><span class="std std-ref">for-upstream: yes</span></a> (default),
authority zones are processed after the cache lookup, just before going to the
network to fetch information for recursion.
When used in this manner they provide a local copy of an authority server
that speeds up lookups for that data during resolving.</p>
<p>If both options are enabled (default), client queries for an authority zone are
answered authoritatively from Unbound, while internal queries that require data
from the authority zone consult the local zone data instead of going to the
network.</p>
<p>An interesting configuration is
<a class="reference internal" href="#unbound-conf-auth-for-downstream"><span class="std std-ref">for-downstream: no</span></a>,
<a class="reference internal" href="#unbound-conf-auth-for-upstream"><span class="std std-ref">for-upstream: yes</span></a>
that allows for hyperlocal behavior where both client and internal queries
consult the local zone data while resolving.
In this case, the aforementioned CNAME example will result in a thoroughly
resolved answer.</p>
<p>Authority zones can be read from zonefile.
And can be kept updated via AXFR and IXFR.
After update the zonefile is rewritten.
The update mechanism uses the SOA timer values and performs SOA UDP queries to
detect zone changes.</p>
<p>If the update fetch fails, the timers in the SOA record are used to time
another fetch attempt.
Until the SOA expiry timer is reached.
Then the zone is expired.
When a zone is expired, queries are SERVFAIL, and any new serial number is
accepted from the primary (even if older), and if fallback is enabled, the
fallback activates to fetch from the upstream instead of the SERVFAIL.</p>
<dl class="simple" id="unbound-conf-auth-name">
<dt>name: <em>&lt;zone name&gt;</em></dt><dd><p>Name of the authority zone.</p>
</dd>
</dl>
<dl id="unbound-conf-auth-primary">
<dt>primary: <em>&lt;IP address or host name&gt;</em></dt><dd><p>Where to download a copy of the zone from, with AXFR and IXFR.
Multiple primaries can be specified.
They are all tried if one fails.</p>
<p>To use a non-default port for DNS communication append <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> with the
port number.</p>
<p>You can append a <code class="docutils literal notranslate"><span class="pre">'#'</span></code> and a name, then AXFR over TLS can be used and the
TLS authentication certificates will be checked with that name.</p>
<p>If you combine the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> and <code class="docutils literal notranslate"><span class="pre">'#'</span></code>, the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> comes first.
If you point it at another Unbound instance, it would not work because that
does not support AXFR/IXFR for the zone, but if you used
<a class="reference internal" href="#unbound-conf-auth-url"><span class="std std-ref">url:</span></a> to download the zonefile as a text file
from a webserver that would work.</p>
<p>If you specify the hostname, you cannot use the domain from the zonefile,
because it may not have that when retrieving that data, instead use a plain
IP address to avoid a circular dependency on retrieving that IP address.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-auth-master">
<dt>master: <em>&lt;IP address or host name&gt;</em></dt><dd><p>Alternate syntax for <a class="reference internal" href="#unbound-conf-auth-primary"><span class="std std-ref">primary:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-auth-url">
<dt>url: <em>&lt;URL to zone file&gt;</em></dt><dd><p>Where to download a zonefile for the zone.
With HTTP or HTTPS.
An example for the url is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>http://www.example.com/example.org.zone
</pre></div>
</div>
<p>Multiple url statements can be given, they are tried in turn.</p>
<p>If only urls are given the SOA refresh timer is used to wait for making new
downloads.
If also primaries are listed, the primaries are first probed with UDP SOA
queries to see if the SOA serial number has changed, reducing the number of
downloads.
If none of the urls work, the primaries are tried with IXFR and AXFR.</p>
<p>For HTTPS, the <a class="reference internal" href="#unbound-conf-tls-cert-bundle"><span class="std std-ref">tls-cert-bundle:</span></a> and
the hostname from the url are used to authenticate the connection.</p>
<p>If you specify a hostname in the URL, you cannot use the domain from the
zonefile, because it may not have that when retrieving that data, instead
use a plain IP address to avoid a circular dependency on retrieving that IP
address.</p>
<p>Avoid dependencies on name lookups by using a notation like
<code class="docutils literal notranslate"><span class="pre">&quot;http://192.0.2.1/unbound-primaries/example.com.zone&quot;</span></code>, with an explicit
IP address.</p>
</dd>
</dl>
<dl id="unbound-conf-auth-allow-notify">
<dt>allow-notify: <em>&lt;IP address or host name or netblockIP/prefix&gt;</em></dt><dd><p>With <a class="reference internal" href="#unbound-conf-auth-allow-notify"><span class="std std-ref">allow-notify:</span></a> you can specify
additional sources of notifies.
When notified, the server attempts to first probe and then zone transfer.
If the notify is from a primary, it first attempts that primary.
Otherwise other primaries are attempted.
If there are no primaries, but only urls, the file is downloaded when
notified.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The primaries from <a class="reference internal" href="#unbound-conf-auth-primary"><span class="std std-ref">primary:</span></a> and
<a class="reference internal" href="#unbound-conf-auth-url"><span class="std std-ref">url:</span></a> statements are allowed notify by
default.</p>
</div>
</dd>
</dl>
<dl id="unbound-conf-auth-fallback-enabled">
<dt>fallback-enabled: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, Unbound falls back to querying the internet as a resolver for
this zone when lookups fail.
For example for DNSSEC validation failures.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-auth-for-downstream">
<dt>for-downstream: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, Unbound serves authority responses to downstream clients for
this zone.
This option makes Unbound behave, for the queries with names in this zone,
like one of the authority servers for that zone.</p>
<p>Turn it off if you want Unbound to provide recursion for the zone but have
a local copy of zone data.</p>
<p>If <a class="reference internal" href="#unbound-conf-auth-for-downstream"><span class="std std-ref">for-downstream: no</span></a> and
<a class="reference internal" href="#unbound-conf-auth-for-upstream"><span class="std std-ref">for-upstream: yes</span></a>, then Unbound will
DNSSEC validate the contents of the zone before serving the zone contents
to clients and store validation results in the cache.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-auth-for-upstream">
<dt>for-upstream: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, Unbound fetches data from this data collection for answering
recursion queries.
Instead of sending queries over the internet to the authority servers for
this zone, it'll fetch the data directly from the zone data.</p>
<p>Turn it on when you want Unbound to provide recursion for downstream
clients, and use the zone data as a local copy to speed up lookups.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-auth-zonemd-check">
<dt>zonemd-check: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable this option to check ZONEMD records in the zone.
The ZONEMD record is a checksum over the zone data.
This includes glue in the zone and data from the zone file, and excludes
comments from the zone file.
When there is a DNSSEC chain of trust, DNSSEC signatures are checked too.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-auth-zonemd-reject-absence">
<dt>zonemd-reject-absence: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable this option to reject the absence of the ZONEMD record.
Without it, when ZONEMD is not there it is not checked.</p>
<p>It is useful to enable for a non-DNSSEC signed zone where the operator
wants to require the verification of a ZONEMD, hence a missing ZONEMD is a
failure.</p>
<p>The action upon failure is controlled by the
<a class="reference internal" href="#unbound-conf-zonemd-permissive-mode"><span class="std std-ref">zonemd-permissive-mode:</span></a> option,
for log only or also block the zone.</p>
<p>Without the option, absence of a ZONEMD is only a failure when the zone is
DNSSEC signed, and we have a trust anchor, and the DNSSEC verification of
the absence of the ZONEMD fails.
With the option enabled, the absence of a ZONEMD is always a failure, also
for nonDNSSEC signed zones.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-auth-zonefile">
<dt>zonefile: <em>&lt;filename&gt;</em></dt><dd><p>The filename where the zone is stored.
If not given then no zonefile is used.
If the file does not exist or is empty, Unbound will attempt to fetch zone
data (eg. from the primary servers).</p>
</dd>
</dl>
</section>
<section id="view-options">
<h3>View Options<a class="headerlink" href="#view-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>There may be multiple <strong>view:</strong> clauses.
Each with a <a class="reference internal" href="#unbound-conf-view-name"><span class="std std-ref">name:</span></a> and zero or more
<a class="reference internal" href="#unbound-conf-view-local-zone"><span class="std std-ref">local-zone:</span></a> and
<a class="reference internal" href="#unbound-conf-view-local-data"><span class="std std-ref">local-data:</span></a> attributes.
Views can also contain <a class="reference internal" href="#unbound-conf-view-view-first"><span class="std std-ref">view-first:</span></a>,
<a class="reference internal" href="#unbound-conf-response-ip"><span class="std std-ref">response-ip:</span></a>,
<a class="reference internal" href="#unbound-conf-response-ip-data"><span class="std std-ref">response-ip-data:</span></a> and
<a class="reference internal" href="#unbound-conf-view-local-data-ptr"><span class="std std-ref">local-data-ptr:</span></a> attributes.
View can be mapped to requests by specifying the view name in an
<a class="reference internal" href="#unbound-conf-access-control-view"><span class="std std-ref">access-control-view:</span></a> attribute.
Options from matching views will override global options.
Global options will be used if no matching view is found, or when the matching
view does not have the option specified.</p>
<dl class="simple" id="unbound-conf-view-name">
<dt>name: <em>&lt;view name&gt;</em></dt><dd><p>Name of the view.
Must be unique.
This name is used in the
<a class="reference internal" href="#unbound-conf-access-control-view"><span class="std std-ref">access-control-view:</span></a> attribute.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-view-local-zone">
<dt>local-zone: <em>&lt;zone&gt; &lt;type&gt;</em></dt><dd><p>View specific local zone elements.
Has the same types and behaviour as the global
<a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> elements.
When there is at least one <em>local-zone:</em> specified and <a class="reference internal" href="#unbound-conf-view-view-first"><span class="std std-ref">view-first:
no</span></a>, the default local-zones will be added to
this view.
Defaults can be disabled using the nodefault type.
When <a class="reference internal" href="#unbound-conf-view-view-first"><span class="std std-ref">view-first: yes</span></a> or when a view
does not have a <a class="reference internal" href="#unbound-conf-view-local-zone"><span class="std std-ref">local-zone:</span></a>, the
global <a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> will be used including
it's default zones.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-view-local-data">
<dt>local-data: <em>&quot;&lt;resource record string&gt;&quot;</em></dt><dd><p>View specific local data elements.
Has the same behaviour as the global
<a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> elements.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-view-local-data-ptr">
<dt>local-data-ptr: <em>&quot;IPaddr name&quot;</em></dt><dd><p>View specific local-data-ptr elements.
Has the same behaviour as the global
<a class="reference internal" href="#unbound-conf-local-data-ptr"><span class="std std-ref">local-data-ptr:</span></a> elements.</p>
</dd>
</dl>
<dl id="unbound-conf-view-view-first">
<dt>view-first: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, it attempts to use the global
<a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> and
<a class="reference internal" href="#unbound-conf-local-data"><span class="std std-ref">local-data:</span></a> if there is no match in the
view specific options.</p>
<p>Default: no</p>
</dd>
</dl>
</section>
<section id="python-module-options">
<h3>Python Module Options<a class="headerlink" href="#python-module-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>The <strong>python:</strong> clause gives the settings for the <em>python(1)</em> script module.
This module acts like the iterator and validator modules do, on queries and
answers.
To enable the script module it has to be compiled into the daemon, and the word
<code class="docutils literal notranslate"><span class="pre">python</span></code> has to be put in the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> option (usually first, or
between the validator and iterator).
Multiple instances of the python module are supported by adding the word
<code class="docutils literal notranslate"><span class="pre">python</span></code> more than once.</p>
<p>If the <a class="reference internal" href="#unbound-conf-chroot"><span class="std std-ref">chroot:</span></a> option is enabled, you should make
sure Python's library directory structure is bind mounted in the new root
environment, see <em>mount(8)</em>.
Also the <a class="reference internal" href="#unbound-conf-python-python-script"><span class="std std-ref">python-script:</span></a> path should
be specified as an absolute path relative to the new root, or as a relative
path to the working directory.</p>
<dl class="simple" id="unbound-conf-python-python-script">
<dt>python-script: <em>&lt;python file&gt;</em></dt><dd><p>The script file to load.
Repeat this option for every python module instance added to the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> option.</p>
</dd>
</dl>
</section>
<section id="dynamic-library-module-options">
<h3>Dynamic Library Module Options<a class="headerlink" href="#dynamic-library-module-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>The <strong>dynlib:</strong> clause gives the settings for the <code class="docutils literal notranslate"><span class="pre">dynlib</span></code> module.
This module is only a very small wrapper that allows dynamic modules to be
loaded on runtime instead of being compiled into the application.
To enable the dynlib module it has to be compiled into the daemon, and the word
<code class="docutils literal notranslate"><span class="pre">dynlib</span></code> has to be put in the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> attribute.
Multiple instances of dynamic libraries are supported by adding the word
<code class="docutils literal notranslate"><span class="pre">dynlib</span></code> more than once.</p>
<p>The <a class="reference internal" href="#unbound-conf-dynlib-dynlib-file"><span class="std std-ref">dynlib-file:</span></a> path should be
specified as an absolute path relative to the new path set by
<a class="reference internal" href="#unbound-conf-chroot"><span class="std std-ref">chroot:</span></a>, or as a relative path to the working
directory.</p>
<dl class="simple" id="unbound-conf-dynlib-dynlib-file">
<dt>dynlib-file: <em>&lt;dynlib file&gt;</em></dt><dd><p>The dynamic library file to load.
Repeat this option for every dynlib module instance added to the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> option.</p>
</dd>
</dl>
</section>
<section id="dns64-module-options">
<h3>DNS64 Module Options<a class="headerlink" href="#dns64-module-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">dns64</span></code> module must be configured in the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> directive, e.g.:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>module-config: &quot;dns64 validator iterator&quot;
</pre></div>
</div>
<p>and be compiled into the daemon to be enabled.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>These settings go in the <a class="reference internal" href="#unbound-conf-server"><span class="std std-ref">server:</span></a> section.</p>
</div>
<dl id="unbound-conf-dns64-dns64-prefix">
<dt>dns64-prefix: <em>&lt;IPv6 prefix&gt;</em></dt><dd><p>This sets the DNS64 prefix to use to synthesize AAAA records with.
It must be /96 or shorter.</p>
<p>Default: 64:ff9b::/96</p>
</dd>
</dl>
<dl id="unbound-conf-dns64-dns64-synthall">
<dt>dns64-synthall: <em>&lt;yes or no&gt;</em></dt><dd><div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Debugging feature!</p>
</div>
<p>If enabled, synthesize all AAAA records despite the presence of actual AAAA
records.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-dns64-dns64-ignore-aaaa">
<dt>dns64-ignore-aaaa: <em>&lt;domain name&gt;</em></dt><dd><p>List domain for which the AAAA records are ignored and the A record is used
by DNS64 processing instead.
Can be entered multiple times, list a new domain for which it applies, one
per line.
Applies also to names underneath the name given.</p>
</dd>
</dl>
</section>
<section id="nat64-operation">
<h3>NAT64 Operation<a class="headerlink" href="#nat64-operation" title="この見出しへのパーマリンク">¶</a></h3>
<p>NAT64 operation allows using a NAT64 prefix for outbound requests to IPv4-only
servers.
It is controlled by two options in the
<a class="reference internal" href="#unbound-conf-server"><span class="std std-ref">server:</span></a> section:</p>
<dl id="unbound-conf-nat64-do-nat64">
<dt>do-nat64: <em>&lt;yes or no&gt;</em></dt><dd><p>Use NAT64 to reach IPv4-only servers.
Consider also enabling <a class="reference internal" href="#unbound-conf-prefer-ip6"><span class="std std-ref">prefer-ip6:</span></a>
to prefer native IPv6 connections to nameservers.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-nat64-nat64-prefix">
<dt>nat64-prefix: <em>&lt;IPv6 prefix&gt;</em></dt><dd><p>Use a specific NAT64 prefix to reach IPv4-only servers.
The prefix length must be one of /32, /40, /48, /56, /64 or /96.</p>
<p>Default: 64:ff9b::/96 (same as <a class="reference internal" href="#unbound-conf-dns64-dns64-prefix"><span class="std std-ref">dns64-prefix:</span></a>)</p>
</dd>
</dl>
</section>
<section id="dnscrypt-options">
<h3>DNSCrypt Options<a class="headerlink" href="#dnscrypt-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>The <strong>dnscrypt:</strong> clause gives the settings of the dnscrypt channel.
While those options are available, they are only meaningful if Unbound was
compiled with <code class="docutils literal notranslate"><span class="pre">--enable-dnscrypt</span></code>.
Currently certificate and secret/public keys cannot be generated by Unbound.
You can use dnscrypt-wrapper to generate those:
<a class="reference external" href="https://github.com/cofyc/dnscrypt-wrapper/blob/master/README.md#usage">https://github.com/cofyc/dnscrypt-wrapper/blob/master/README.md#usage</a></p>
<dl id="unbound-conf-dnscrypt-dnscrypt-enable">
<dt>dnscrypt-enable: <em>&lt;yes or no&gt;</em></dt><dd><p>Whether or not the dnscrypt config should be enabled.
You may define configuration but not activate it.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-dnscrypt-dnscrypt-port">
<dt>dnscrypt-port: <em>&lt;port number&gt;</em></dt><dd><p>On which port should dnscrypt should be activated.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>There should be a matching interface option defined in the
<a class="reference internal" href="#unbound-conf-server"><span class="std std-ref">server:</span></a> section for this port.</p>
</div>
</dd>
</dl>
<dl class="simple" id="unbound-conf-dnscrypt-dnscrypt-provider">
<dt>dnscrypt-provider: <em>&lt;provider name&gt;</em></dt><dd><p>The provider name to use to distribute certificates.
This is of the form: <code class="docutils literal notranslate"><span class="pre">2.dnscrypt-cert.example.com.</span></code>.
The name <em>MUST</em> end with a dot.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-dnscrypt-dnscrypt-secret-key">
<dt>dnscrypt-secret-key: <em>&lt;path to secret key file&gt;</em></dt><dd><p>Path to the time limited secret key file.
This option may be specified multiple times.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-dnscrypt-dnscrypt-provider-cert">
<dt>dnscrypt-provider-cert: <em>&lt;path to cert file&gt;</em></dt><dd><p>Path to the certificate related to the
<a class="reference internal" href="#unbound-conf-dnscrypt-dnscrypt-secret-key"><span class="std std-ref">dnscrypt-secret-key:</span></a>.
This option may be specified multiple times.</p>
</dd>
</dl>
<dl id="unbound-conf-dnscrypt-dnscrypt-provider-cert-rotated">
<dt>dnscrypt-provider-cert-rotated: <em>&lt;path to cert file&gt;</em></dt><dd><p>Path to a certificate that we should be able to serve existing connection
from but do not want to advertise over
<a class="reference internal" href="#unbound-conf-dnscrypt-dnscrypt-provider"><span class="std std-ref">dnscrypt-provider:</span></a> 's TXT
record certs distribution.</p>
<p>A typical use case is when rotating certificates, existing clients may
still use the client magic from the old cert in their queries until they
fetch and update the new cert.
Likewise, it would allow one to prime the new cert/key without distributing
the new cert yet, this can be useful when using a network of servers using
anycast and on which the configuration may not get updated at the exact
same time.</p>
<p>By priming the cert, the servers can handle both old and new certs traffic
while distributing only one.</p>
<p>This option may be specified multiple times.</p>
</dd>
</dl>
<dl id="unbound-conf-dnscrypt-dnscrypt-shared-secret-cache-size">
<dt>dnscrypt-shared-secret-cache-size: <em>&lt;memory size&gt;</em></dt><dd><p>Give the size of the data structure in which the shared secret keys are
kept in.
In bytes or use m(mega), k(kilo), g(giga).
The shared secret cache is used when a same client is making multiple
queries using the same public key.
It saves a substantial amount of CPU.</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-dnscrypt-dnscrypt-shared-secret-cache-slabs">
<dt>dnscrypt-shared-secret-cache-slabs: <em>&lt;number&gt;</em></dt><dd><p>Give power of 2 number of slabs, this is used to reduce lock contention in
the dnscrypt shared secrets cache.
Close to the number of cpus is a fairly good setting.</p>
<p>Default: 4</p>
</dd>
</dl>
<dl id="unbound-conf-dnscrypt-dnscrypt-nonce-cache-size">
<dt>dnscrypt-nonce-cache-size: <em>&lt;memory size&gt;</em></dt><dd><p>Give the size of the data structure in which the client nonces are kept in.
In bytes or use m(mega), k(kilo), g(giga).
The nonce cache is used to prevent dnscrypt message replaying.
Client nonce should be unique for any pair of client pk/server sk.</p>
<p>Default: 4m</p>
</dd>
</dl>
<dl id="unbound-conf-dnscrypt-dnscrypt-nonce-cache-slabs">
<dt>dnscrypt-nonce-cache-slabs: <em>&lt;number&gt;</em></dt><dd><p>Give power of 2 number of slabs, this is used to reduce lock contention in
the dnscrypt nonce cache.
Close to the number of cpus is a fairly good setting.</p>
<p>Default: 4</p>
</dd>
</dl>
</section>
<section id="edns-client-subnet-module-options">
<h3>EDNS Client Subnet Module Options<a class="headerlink" href="#edns-client-subnet-module-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>The ECS module must be configured in the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> directive, e.g.:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>module-config: &quot;subnetcache validator iterator&quot;
</pre></div>
</div>
<p>and be compiled into the daemon to be enabled.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>These settings go in the <a class="reference internal" href="#unbound-conf-server"><span class="std std-ref">server:</span></a> section.</p>
</div>
<p>If the destination address is allowed in the configuration Unbound will add the
EDNS0 option to the query containing the relevant part of the client's address.
When an answer contains the ECS option the response and the option are placed
in a specialized cache.
If the authority indicated no support, the response is stored in the regular
cache.</p>
<p>Additionally, when a client includes the option in its queries, Unbound will
forward the option when sending the query to addresses that are explicitly
allowed in the configuration using
<a class="reference internal" href="#unbound-conf-ecs-send-client-subnet"><span class="std std-ref">send-client-subnet:</span></a>.
The option will always be forwarded, regardless the allowed addresses, when
<a class="reference internal" href="#unbound-conf-ecs-client-subnet-always-forward"><span class="std std-ref">client-subnet-always-forward:
yes</span></a>.
In this case the lookup in the regular cache is skipped.</p>
<p>The maximum size of the ECS cache is controlled by
<a class="reference internal" href="#unbound-conf-msg-cache-size"><span class="std std-ref">msg-cache-size:</span></a> in the configuration file.
On top of that, for each query only 100 different subnets are allowed to be
stored for each address family.
Exceeding that number, older entries will be purged from cache.</p>
<p>This module does not interact with the
<a class="reference internal" href="#unbound-conf-serve-expired"><span class="std std-ref">serve-expired*:</span></a> and
<a class="reference internal" href="#unbound-conf-prefetch"><span class="std std-ref">prefetch:</span></a> options.</p>
<dl class="simple" id="unbound-conf-ecs-send-client-subnet">
<dt>send-client-subnet: <em>&lt;IP address&gt;</em></dt><dd><p>Send client source address to this authority.
Append /num to indicate a classless delegation netblock, for example like
<code class="docutils literal notranslate"><span class="pre">10.2.3.4/24</span></code> or <code class="docutils literal notranslate"><span class="pre">2001::11/64</span></code>.
Can be given multiple times.
Authorities not listed will not receive edns-subnet information, unless
domain in query is specified in
<a class="reference internal" href="#unbound-conf-ecs-client-subnet-zone"><span class="std std-ref">client-subnet-zone:</span></a>.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ecs-client-subnet-zone">
<dt>client-subnet-zone: <em>&lt;domain&gt;</em></dt><dd><p>Send client source address in queries for this domain and its subdomains.
Can be given multiple times.
Zones not listed will not receive edns-subnet information, unless hosted by
authority specified in
<a class="reference internal" href="#unbound-conf-ecs-send-client-subnet"><span class="std std-ref">send-client-subnet:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-ecs-client-subnet-always-forward">
<dt>client-subnet-always-forward: <em>&lt;yes or no&gt;</em></dt><dd><p>Specify whether the ECS address check (configured using
<a class="reference internal" href="#unbound-conf-ecs-send-client-subnet"><span class="std std-ref">send-client-subnet:</span></a>) is applied
for all queries, even if the triggering query contains an ECS record, or
only for queries for which the ECS record is generated using the querier
address (and therefore did not contain ECS data in the client query).
If enabled, the address check is skipped when the client query contains an
ECS record.
And the lookup in the regular cache is skipped.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-ecs-max-client-subnet-ipv6">
<dt>max-client-subnet-ipv6: <em>&lt;number&gt;</em></dt><dd><p>Specifies the maximum prefix length of the client source address we are
willing to expose to third parties for IPv6.</p>
<p>Default: 56</p>
</dd>
</dl>
<dl id="unbound-conf-ecs-max-client-subnet-ipv4">
<dt>max-client-subnet-ipv4: <em>&lt;number&gt;</em></dt><dd><p>Specifies the maximum prefix length of the client source address we are
willing to expose to third parties for IPv4.</p>
<p>Default: 24</p>
</dd>
</dl>
<dl id="unbound-conf-ecs-min-client-subnet-ipv6">
<dt>min-client-subnet-ipv6: <em>&lt;number&gt;</em></dt><dd><p>Specifies the minimum prefix length of the IPv6 source mask we are willing
to accept in queries.
Shorter source masks result in REFUSED answers.
Source mask of 0 is always accepted.</p>
<p>Default: 0</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ecs-min-client-subnet-ipv4">
<dt>min-client-subnet-ipv4: <em>&lt;number&gt;</em></dt><dd><p>Specifies the minimum prefix length of the IPv4 source mask we are willing
to accept in queries.
Shorter source masks result in REFUSED answers.
Source mask of 0 is always accepted.
Default: 0</p>
</dd>
</dl>
<dl id="unbound-conf-ecs-max-ecs-tree-size-ipv4">
<dt>max-ecs-tree-size-ipv4: <em>&lt;number&gt;</em></dt><dd><p>Specifies the maximum number of subnets ECS answers kept in the ECS radix
tree.
This number applies for each qname/qclass/qtype tuple.</p>
<p>Default: 100</p>
</dd>
</dl>
<dl id="unbound-conf-ecs-max-ecs-tree-size-ipv6">
<dt>max-ecs-tree-size-ipv6: <em>&lt;number&gt;</em></dt><dd><p>Specifies the maximum number of subnets ECS answers kept in the ECS radix
tree.
This number applies for each qname/qclass/qtype tuple.</p>
<p>Default: 100</p>
</dd>
</dl>
</section>
<section id="opportunistic-ipsec-support-module-options">
<h3>Opportunistic IPsec Support Module Options<a class="headerlink" href="#opportunistic-ipsec-support-module-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>The IPsec module must be configured in the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> directive, e.g.:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>module-config: &quot;ipsecmod validator iterator&quot;
</pre></div>
</div>
<p>and be compiled into Unbound by using <code class="docutils literal notranslate"><span class="pre">--enable-ipsecmod</span></code> to be enabled.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>These settings go in the <a class="reference internal" href="#unbound-conf-server"><span class="std std-ref">server:</span></a> section.</p>
</div>
<p>When Unbound receives an A/AAAA query that is not in the cache and finds a
valid answer, it will withhold returning the answer and instead will generate
an IPSECKEY subquery for the same domain name.
If an answer was found, Unbound will call an external hook passing the
following arguments:</p>
<dl class="simple">
<dt>QNAME</dt><dd><p>Domain name of the A/AAAA and IPSECKEY query.
In string format.</p>
</dd>
<dt>IPSECKEY TTL</dt><dd><p>TTL of the IPSECKEY RRset.</p>
</dd>
<dt>A/AAAA</dt><dd><p>String of space separated IP addresses present in the A/AAAA RRset.
The IP addresses are in string format.</p>
</dd>
<dt>IPSECKEY</dt><dd><p>String of space separated IPSECKEY RDATA present in the IPSECKEY RRset.
The IPSECKEY RDATA are in DNS presentation format.</p>
</dd>
</dl>
<p>The A/AAAA answer is then cached and returned to the client.
If the external hook was called the TTL changes to ensure it doesn't surpass
<a class="reference internal" href="#unbound-conf-ipsecmod-max-ttl"><span class="std std-ref">ipsecmod-max-ttl:</span></a>.</p>
<p>The same procedure is also followed when <a class="reference internal" href="#unbound-conf-prefetch"><span class="std std-ref">prefetch:
yes</span></a> is used, but the A/AAAA answer is given to the
client before the hook is called.
<a class="reference internal" href="#unbound-conf-ipsecmod-max-ttl"><span class="std std-ref">ipsecmod-max-ttl:</span></a> ensures that the A/AAAA
answer given from cache is still relevant for opportunistic IPsec.</p>
<dl id="unbound-conf-ipsecmod-enabled">
<dt>ipsecmod-enabled: <em>&lt;yes or no&gt;</em></dt><dd><p>Specifies whether the IPsec module is enabled or not.
The IPsec module still needs to be defined in the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> directive.
This option facilitates turning on/off the module without
restarting/reloading Unbound.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ipsecmod-hook">
<dt>ipsecmod-hook: <em>&lt;filename&gt;</em></dt><dd><p>Specifies the external hook that Unbound will call with <em>system(3)</em>.
The file can be specified as an absolute/relative path.
The file needs the proper permissions to be able to be executed by the same
user that runs Unbound.
It must be present when the IPsec module is defined in the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> directive.</p>
</dd>
</dl>
<dl id="unbound-conf-ipsecmod-strict">
<dt>ipsecmod-strict: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled Unbound requires the external hook to return a success value of
0.
Failing to do so Unbound will reply with SERVFAIL.
The A/AAAA answer will also not be cached.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-ipsecmod-max-ttl">
<dt>ipsecmod-max-ttl: <em>&lt;seconds&gt;</em></dt><dd><p>Time to live maximum for A/AAAA cached records after calling the external
hook.</p>
<p>Default: 3600</p>
</dd>
</dl>
<dl id="unbound-conf-ipsecmod-ignore-bogus">
<dt>ipsecmod-ignore-bogus: <em>&lt;yes or no&gt;</em></dt><dd><p>Specifies the behaviour of Unbound when the IPSECKEY answer is bogus.
If set to yes, the hook will be called and the A/AAAA answer will be
returned to the client.
If set to no, the hook will not be called and the answer to the A/AAAA
query will be SERVFAIL.
Mainly used for testing.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ipsecmod-allow">
<dt>ipsecmod-allow: <em>&lt;domain&gt;</em></dt><dd><p>Allow the IPsec module functionality for the domain so that the module
logic will be executed.
Can be given multiple times, for different domains.
If the option is not specified, all domains are treated as being allowed
(default).</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-ipsecmod-whitelist">
<dt>ipsecmod-whitelist: <em>&lt;yes or no&gt;</em></dt><dd><p>Alternate syntax for <a class="reference internal" href="#unbound-conf-ipsecmod-allow"><span class="std std-ref">ipsecmod-allow:</span></a>.</p>
</dd>
</dl>
</section>
<section id="cache-db-module-options">
<h3>Cache DB Module Options<a class="headerlink" href="#cache-db-module-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>The Cache DB module must be configured in the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config:</span></a> directive, e.g.:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>module-config: &quot;validator cachedb iterator&quot;
</pre></div>
</div>
<p>and be compiled into the daemon with <code class="docutils literal notranslate"><span class="pre">--enable-cachedb</span></code>.</p>
<p>If this module is enabled and configured, the specified backend database works
as a second level cache; when Unbound cannot find an answer to a query in its
built-in in-memory cache, it consults the specified backend.
If it finds a valid answer in the backend, Unbound uses it to respond to the
query without performing iterative DNS resolution.
If Unbound cannot even find an answer in the backend, it resolves the query as
usual, and stores the answer in the backend.</p>
<p>This module interacts with the <em>serve-expired-*</em> options and will reply with
expired data if Unbound is configured for that.
Currently the use of
<a class="reference internal" href="#unbound-conf-serve-expired-client-timeout"><span class="std std-ref">serve-expired-client-timeout:</span></a>
and <a class="reference internal" href="#unbound-conf-serve-expired-reply-ttl"><span class="std std-ref">serve-expired-reply-ttl:</span></a> is
not consistent for data originating from the external cache as these will
result in a reply with 0 TTL without trying to update the data first, ignoring
the configured values.</p>
<p>If Unbound was built with <code class="docutils literal notranslate"><span class="pre">--with-libhiredis</span></code> on a system that has installed
the hiredis C client library of Redis, then the <code class="docutils literal notranslate"><span class="pre">redis</span></code> backend can be used.
This backend communicates with the specified Redis server over a TCP connection
to store and retrieve cache data.
It can be used as a persistent and/or shared cache backend.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Unbound never removes data stored in the Redis server, even if some data
have expired in terms of DNS TTL or the Redis server has cached too much
data; if necessary the Redis server must be configured to limit the cache
size, preferably with some kind of least-recently-used eviction policy.</p>
</div>
<p>Additionally, the
<a class="reference internal" href="#unbound-conf-cachedb-redis-expire-records"><span class="std std-ref">redis-expire-records:</span></a> option
can be used in order to set the relative DNS TTL of the message as timeout to
the Redis records; keep in mind that some additional memory is used per key and
that the expire information is stored as absolute Unix timestamps in Redis
(computer time must be stable).</p>
<p>This backend uses synchronous communication with the Redis server based on the
assumption that the communication is stable and sufficiently fast.
The thread waiting for a response from the Redis server cannot handle other DNS
queries.
Although the backend has the ability to reconnect to the server when the
connection is closed unexpectedly and there is a configurable timeout in case
the server is overly slow or hangs up, these cases are assumed to be very rare.
If connection close or timeout happens too often, Unbound will be effectively
unusable with this backend.
It's the administrator's responsibility to make the assumption hold.</p>
<p>The <strong>cachedb:</strong> clause gives custom settings of the cache DB module.</p>
<dl id="unbound-conf-cachedb-backend">
<dt>backend: <em>&lt;backend name&gt;</em></dt><dd><p>Specify the backend database name.
The default database is the in-memory backend named <code class="docutils literal notranslate"><span class="pre">testframe</span></code>, which,
as the name suggests, is not of any practical use.
Depending on the build-time configuration, <code class="docutils literal notranslate"><span class="pre">redis</span></code> backend may also be
used as described above.</p>
<p>Default: testframe</p>
</dd>
</dl>
<dl id="unbound-conf-cachedb-secret-seed">
<dt>secret-seed: <em>&quot;&lt;secret string&gt;&quot;</em></dt><dd><p>Specify a seed to calculate a hash value from query information.
This value will be used as the key of the corresponding answer for the
backend database and can be customized if the hash should not be
predictable operationally.
If the backend database is shared by multiple Unbound instances, all
instances must use the same secret seed.</p>
<p>Default: &quot;default&quot;</p>
</dd>
<dt>cachedb-no-store: <em>&lt;yes or no&gt;</em></dt><dd><p>If the backend should be read from, but not written to.
This makes this instance not store dns messages in the backend.
But if data is available it is retrieved.</p>
<p>Default: no</p>
</dd>
</dl>
<p>The following <strong>cachedb:</strong> options are specific to the <code class="docutils literal notranslate"><span class="pre">redis</span></code> backend.</p>
<dl id="unbound-conf-cachedb-redis-server-host">
<dt>redis-server-host: <em>&lt;server address or name&gt;</em></dt><dd><p>The IP (either v6 or v4) address or domain name of the Redis server.
In general an IP address should be specified as otherwise Unbound will have
to resolve the name of the server every time it establishes a connection to
the server.</p>
<p>Default: 127.0.0.1</p>
</dd>
</dl>
<dl id="unbound-conf-cachedb-redis-server-port">
<dt>redis-server-port: <em>&lt;port number&gt;</em></dt><dd><p>The TCP port number of the Redis server.</p>
<p>Default: 6379</p>
</dd>
</dl>
<dl id="unbound-conf-cachedb-redis-server-path">
<dt>redis-server-path: <em>&lt;unix socket path&gt;</em></dt><dd><p>The unix socket path to connect to the redis server.
Unix sockets may have better throughput than the IP address option.</p>
<p>Default: &quot;&quot; (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-cachedb-redis-server-password">
<dt>redis-server-password: <em>&quot;&lt;password&gt;&quot;</em></dt><dd><p>The Redis AUTH password to use for the redis server.
Only relevant if Redis is configured for client password authorisation.</p>
<p>Default: &quot;&quot; (disabled)</p>
</dd>
</dl>
<dl id="unbound-conf-cachedb-redis-timeout">
<dt>redis-timeout: <em>&lt;msec&gt;</em></dt><dd><p>The period until when Unbound waits for a response from the Redis sever.
If this timeout expires Unbound closes the connection, treats it as if the
Redis server does not have the requested data, and will try to re-establish
a new connection later.</p>
<p>Default: 100</p>
</dd>
</dl>
<dl id="unbound-conf-cachedb-redis-expire-records">
<dt>redis-expire-records: <em>&lt;yes or no&gt;</em></dt><dd><p>If Redis record expiration is enabled.
If yes, Unbound sets timeout for Redis records so that Redis can evict keys
that have expired automatically.
If Unbound is configured with
<a class="reference internal" href="#unbound-conf-serve-expired"><span class="std std-ref">serve-expired:</span></a> and
<a class="reference internal" href="#unbound-conf-serve-expired-ttl"><span class="std std-ref">serve-expired-ttl: 0</span></a>, this option is
internally reverted to &quot;no&quot;.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Redis SETEX support is required for this option (Redis &gt;= 2.0.0).</p>
</div>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-cachedb-redis-logical-db">
<dt>redis-logical-db: <em>&lt;logical database index&gt;</em></dt><dd><p>The logical database in Redis to use.
These are databases in the same Redis instance sharing the same
configuration and persisted in the same RDB/AOF file.
If unsure about using this option, Redis documentation
(<a class="reference external" href="https://redis.io/commands/select/">https://redis.io/commands/select/</a>) suggests not to use a single Redis
instance for multiple unrelated applications.
The default database in Redis is 0 while other logical databases need to be
explicitly SELECT'ed upon connecting.</p>
<p>Default: 0</p>
</dd>
</dl>
</section>
<section id="dnstap-logging-options">
<h3>DNSTAP Logging Options<a class="headerlink" href="#dnstap-logging-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>DNSTAP support, when compiled in by using <code class="docutils literal notranslate"><span class="pre">--enable-dnstap</span></code>, is enabled in
the <strong>dnstap:</strong> section.
This starts an extra thread (when compiled with threading) that writes the log
information to the destination.
If Unbound is compiled without threading it does not spawn a thread, but
connects per-process to the destination.</p>
<dl id="unbound-conf-dnstap-dnstap-enable">
<dt>dnstap-enable: <em>&lt;yes or no&gt;</em></dt><dd><p>If dnstap is enabled.
If yes, it connects to the DNSTAP server and if any of the
<em>dnstap-log-..-messages:</em> options is enabled it sends logs for those
messages to the server.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-bidirectional">
<dt>dnstap-bidirectional: <em>&lt;yes or no&gt;</em></dt><dd><p>Use frame streams in bidirectional mode to transfer DNSTAP messages.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-socket-path">
<dt>dnstap-socket-path: <em>&lt;file name&gt;</em></dt><dd><p>Sets the unix socket file name for connecting to the server that is
listening on that socket.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-ip">
<dt>dnstap-ip: <em>&lt;IPaddress[&#64;port]&gt;</em></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, the unix socket is used, if set with an IP address (IPv4 or
IPv6) that address is used to connect to the server.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-tls">
<dt>dnstap-tls: <em>&lt;yes or no&gt;</em></dt><dd><p>Set this to use TLS to connect to the server specified in
<a class="reference internal" href="#unbound-conf-dnstap-dnstap-ip"><span class="std std-ref">dnstap-ip:</span></a>.
If set to no, TCP is used to connect to the server.</p>
<p>Default: yes</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-tls-server-name">
<dt>dnstap-tls-server-name: <em>&lt;name of TLS authentication&gt;</em></dt><dd><p>The TLS server name to authenticate the server with.
Used when <a class="reference internal" href="#unbound-conf-dnstap-dnstap-tls"><span class="std std-ref">dnstap-tls: yes</span></a>.
If <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> it is ignored.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-tls-cert-bundle">
<dt>dnstap-tls-cert-bundle: <em>&lt;file name of cert bundle&gt;</em></dt><dd><p>The pem file with certs to verify the TLS server certificate.
If <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> the server default cert bundle is used, or the windows cert
bundle on windows.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-tls-client-key-file">
<dt>dnstap-tls-client-key-file: <em>&lt;file name&gt;</em></dt><dd><p>The client key file for TLS client authentication.
If <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> client authentication is not used.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-tls-client-cert-file">
<dt>dnstap-tls-client-cert-file: <em>&lt;file name&gt;</em></dt><dd><p>The client cert file for TLS client authentication.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-send-identity">
<dt>dnstap-send-identity: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, the server identity is included in the log messages.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-send-version">
<dt>dnstap-send-version: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled, the server version if included in the log messages.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-identity">
<dt>dnstap-identity: <em>&lt;string&gt;</em></dt><dd><p>The identity to send with messages, if <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> the hostname is used.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-version">
<dt>dnstap-version: <em>&lt;string&gt;</em></dt><dd><p>The version to send with messages, if <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> the package version is used.</p>
<p>Default: &quot;&quot;</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-log-resolver-query-messages">
<dt>dnstap-log-resolver-query-messages: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable to log resolver query messages.
These are messages from Unbound to upstream servers.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-log-resolver-response-messages">
<dt>dnstap-log-resolver-response-messages: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable to log resolver response messages.
These are replies from upstream servers to Unbound.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-log-client-query-messages">
<dt>dnstap-log-client-query-messages: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable to log client query messages.
These are client queries to Unbound.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-log-client-response-messages">
<dt>dnstap-log-client-response-messages: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable to log client response messages.
These are responses from Unbound to clients.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-log-forwarder-query-messages">
<dt>dnstap-log-forwarder-query-messages: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable to log forwarder query messages.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-dnstap-dnstap-log-forwarder-response-messages">
<dt>dnstap-log-forwarder-response-messages: <em>&lt;yes or no&gt;</em></dt><dd><p>Enable to log forwarder response messages.</p>
<p>Default: no</p>
</dd>
</dl>
</section>
<section id="response-policy-zone-options">
<span id="unbound-conf-rpz"></span><h3>Response Policy Zone Options<a class="headerlink" href="#response-policy-zone-options" title="この見出しへのパーマリンク">¶</a></h3>
<p>Response Policy Zones are configured with <strong>rpz:</strong>, and each one must have a
<a class="reference internal" href="#unbound-conf-rpz-name"><span class="std std-ref">name:</span></a>.
There can be multiple ones, by listing multiple rpz clauses, each with a
different name.
RPZ clauses are applied in order of configuration.
The respip module needs to be added to the
<a class="reference internal" href="#unbound-conf-module-config"><span class="std std-ref">module-config</span></a>, e.g.:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>module-config: &quot;respip validator iterator&quot;
</pre></div>
</div>
<p>QNAME, Response IP Address, nsdname, nsip and clientip triggers are supported.
Supported actions are: NXDOMAIN, NODATA, PASSTHRU, DROP, Local Data, tcp-only
and drop.
RPZ QNAME triggers are applied after any
<a class="reference internal" href="#unbound-conf-local-zone"><span class="std std-ref">local-zone:</span></a> and before any
<a class="reference internal" href="#unbound-conf-auth"><span class="std std-ref">auth-zone:</span></a>.</p>
<p>The RPZ zone is formatted with a SOA start record as usual.
The items in the zone are entries, that specify what to act on (the trigger)
and what to do (the action).
The trigger to act on is recorded in the name, the action to do is recorded as
the resource record.
The names all end in the zone name, so you could type the trigger names without
a trailing dot in the zonefile.</p>
<p>An example RPZ record, that answers <code class="docutils literal notranslate"><span class="pre">example.com</span></code> with <code class="docutils literal notranslate"><span class="pre">NXDOMAIN</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>example.com CNAME .
</pre></div>
</div>
<p>The triggers are encoded in the name on the left</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>name                          query name
netblock.rpz-client-ip        client IP address
netblock.rpz-ip               response IP address in the answer
name.rpz-nsdname              nameserver name
netblock.rpz-nsip             nameserver IP address
</pre></div>
</div>
<p>The netblock is written as <code class="docutils literal notranslate"><span class="pre">&lt;netblocklen&gt;.&lt;ip</span> <span class="pre">address</span> <span class="pre">in</span> <span class="pre">reverse&gt;</span></code>.
For IPv6 use <code class="docutils literal notranslate"><span class="pre">'zz'</span></code> for <code class="docutils literal notranslate"><span class="pre">'::'</span></code>.
Specify individual addresses with scope length of 32 or 128.
For example, <code class="docutils literal notranslate"><span class="pre">24.10.100.51.198.rpz-ip</span></code> is <code class="docutils literal notranslate"><span class="pre">198.51.100.10/24</span></code> and
<code class="docutils literal notranslate"><span class="pre">32.10.zz.db8.2001.rpz-ip</span></code> is <code class="docutils literal notranslate"><span class="pre">2001:db8:0:0:0:0:0:10/32</span></code>.</p>
<p>The actions are specified with the record on the right</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>CNAME .                      nxdomain reply
CNAME *.                     nodata reply
CNAME rpz-passthru.          do nothing, allow to continue
CNAME rpz-drop.              the query is dropped
CNAME rpz-tcp-only.          answer over TCP
A 192.0.2.1                  answer with this IP address
</pre></div>
</div>
<p>Other records like AAAA, TXT and other CNAMEs (not rpz-..) can also be used to
answer queries with that content.</p>
<p>The RPZ zones can be configured in the config file with these settings in the
<strong>rpz:</strong> block.</p>
<dl class="simple" id="unbound-conf-rpz-name">
<dt>name: <em>&lt;zone name&gt;</em></dt><dd><p>Name of the authority zone.</p>
</dd>
</dl>
<dl id="unbound-conf-rpz-primary">
<dt>primary: <em>&lt;IP address or host name&gt;</em></dt><dd><p>Where to download a copy of the zone from, with AXFR and IXFR.
Multiple primaries can be specified.
They are all tried if one fails.</p>
<p>To use a non-default port for DNS communication append <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> with the
port number.</p>
<p>You can append a <code class="docutils literal notranslate"><span class="pre">'#'</span></code> and a name, then AXFR over TLS can be used and the
TLS authentication certificates will be checked with that name.</p>
<p>If you combine the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> and <code class="docutils literal notranslate"><span class="pre">'#'</span></code>, the <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> comes first.
If you point it at another Unbound instance, it would not work because that
does not support AXFR/IXFR for the zone, but if you used
<a class="reference internal" href="#unbound-conf-rpz-url"><span class="std std-ref">url:</span></a> to download the zonefile as a text file
from a webserver that would work.</p>
<p>If you specify the hostname, you cannot use the domain from the zonefile,
because it may not have that when retrieving that data, instead use a plain
IP address to avoid a circular dependency on retrieving that IP address.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-rpz-master">
<dt>master: <em>&lt;IP address or host name&gt;</em></dt><dd><p>Alternate syntax for <a class="reference internal" href="#unbound-conf-rpz-primary"><span class="std std-ref">primary:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-rpz-url">
<dt>url: <em>&lt;url to zonefile&gt;</em></dt><dd><p>Where to download a zonefile for the zone.
With HTTP or HTTPS.
An example for the url is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>http://www.example.com/example.org.zone
</pre></div>
</div>
<p>Multiple url statements can be given, they are tried in turn.</p>
<p>If only urls are given the SOA refresh timer is used to wait for making new
downloads.
If also primaries are listed, the primaries are first probed with UDP SOA
queries to see if the SOA serial number has changed, reducing the number of
downloads.
If none of the URLs work, the primaries are tried with IXFR and AXFR.</p>
<p>For HTTPS, the <a class="reference internal" href="#unbound-conf-tls-cert-bundle"><span class="std std-ref">tls-cert-bundle:</span></a> and
the hostname from the url are used to authenticate the connection.</p>
</dd>
</dl>
<dl id="unbound-conf-rpz-allow-notify">
<dt>allow-notify: <em>&lt;IP address or host name or netblockIP / prefix&gt;</em></dt><dd><p>With <a class="reference internal" href="#unbound-conf-rpz-allow-notify"><span class="std std-ref">allow-notify:</span></a> you can specify
additional sources of notifies.
When notified, the server attempts to first probe and then zone transfer.
If the notify is from a primary, it first attempts that primary.
Otherwise other primaries are attempted.
If there are no primaries, but only urls, the file is downloaded when
notified.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The primaries from <a class="reference internal" href="#unbound-conf-rpz-primary"><span class="std std-ref">primary:</span></a> and
<a class="reference internal" href="#unbound-conf-rpz-url"><span class="std std-ref">url:</span></a> statements are allowed notify by
default.</p>
</div>
</dd>
</dl>
<dl class="simple" id="unbound-conf-rpz-zonefile">
<dt>zonefile: <em>&lt;filename&gt;</em></dt><dd><p>The filename where the zone is stored.
If not given then no zonefile is used.
If the file does not exist or is empty, Unbound will attempt to fetch zone
data (eg. from the primary servers).</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-rpz-rpz-action-override">
<dt>rpz-action-override: <em>&lt;action&gt;</em></dt><dd><p>Always use this RPZ action for matching triggers from this zone.
Possible actions are: <em>nxdomain</em>, <em>nodata</em>, <em>passthru</em>, <em>drop</em>, <em>disabled</em>
and <em>cname</em>.</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-rpz-rpz-cname-override">
<dt>rpz-cname-override: <em>&lt;domain&gt;</em></dt><dd><p>The CNAME target domain to use if the cname action is configured for
<a class="reference internal" href="#unbound-conf-rpz-rpz-action-override"><span class="std std-ref">rpz-action-override:</span></a>.</p>
</dd>
</dl>
<dl id="unbound-conf-rpz-rpz-log">
<dt>rpz-log: <em>&lt;yes or no&gt;</em></dt><dd><p>Log all applied RPZ actions for this RPZ zone.</p>
<p>Default: no</p>
</dd>
</dl>
<dl class="simple" id="unbound-conf-rpz-rpz-log-name">
<dt>rpz-log-name: <em>&lt;name&gt;</em></dt><dd><p>Specify a string to be part of the log line, for easy referencing.</p>
</dd>
</dl>
<dl id="unbound-conf-rpz-rpz-signal-nxdomain-ra">
<dt>rpz-signal-nxdomain-ra: <em>&lt;yes or no&gt;</em></dt><dd><p>Signal when a query is blocked by the RPZ with NXDOMAIN with an unset RA
flag.
This allows certain clients, like dnsmasq, to infer that the domain is
externally blocked.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-rpz-for-downstream">
<dt>for-downstream: <em>&lt;yes or no&gt;</em></dt><dd><p>If enabled the zone is authoritatively answered for and queries for the RPZ
zone information are answered to downstream clients.
This is useful for monitoring scripts, that can then access the SOA
information to check if the RPZ information is up to date.</p>
<p>Default: no</p>
</dd>
</dl>
<dl id="unbound-conf-rpz-tags">
<dt>tags: <em>&quot;&lt;list of tags&gt;&quot;</em></dt><dd><p>Limit the policies from this RPZ clause to clients with a matching tag.</p>
<p>Tags need to be defined in <a class="reference internal" href="#unbound-conf-define-tag"><span class="std std-ref">define-tag:</span></a> and
can be assigned to client addresses using
<a class="reference internal" href="#unbound-conf-access-control-tag"><span class="std std-ref">access-control-tag:</span></a> or
<a class="reference internal" href="#unbound-conf-interface-tag"><span class="std std-ref">interface-tag:</span></a>.
Enclose list of tags in quotes (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>) and put spaces between tags.</p>
<p>If no tags are specified the policies from this clause will be applied for
all clients.</p>
</dd>
</dl>
</section>
</section>
<section id="memory-control-example">
<h2>Memory Control Example<a class="headerlink" href="#memory-control-example" title="この見出しへのパーマリンク">¶</a></h2>
<p>In the example config settings below memory usage is reduced.
Some service levels are lower, notable very large data and a high TCP load are
no longer supported.
Very large data and high TCP loads are exceptional for the DNS.
DNSSEC validation is enabled, just add trust anchors.
If you do not have to worry about programs using more than 3 Mb of memory, the
below example is not for you.
Use the defaults to receive full service, which on BSD-32bit tops out at 30-40
Mb after heavy usage.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># example settings that reduce memory usage
server:
num-threads: 1
outgoing-num-tcp: 1 # this limits TCP service, uses less buffers.
incoming-num-tcp: 1
outgoing-range: 60  # uses less memory, but less performance.
msg-buffer-size: 8192   # note this limits service, &#39;no huge stuff&#39;.
msg-cache-size: 100k
msg-cache-slabs: 1
rrset-cache-size: 100k
rrset-cache-slabs: 1
infra-cache-numhosts: 200
infra-cache-slabs: 1
key-cache-size: 100k
key-cache-slabs: 1
neg-cache-size: 10k
num-queries-per-thread: 30
target-fetch-policy: &quot;2 1 0 0 0 0&quot;
harden-large-queries: &quot;yes&quot;
harden-short-bufsize: &quot;yes&quot;
</pre></div>
</div>
</section>
<section id="files">
<h2>Files<a class="headerlink" href="#files" title="この見出しへのパーマリンク">¶</a></h2>
<dl class="simple">
<dt>/usr/local/etc/unbound</dt><dd><p>default Unbound working directory.</p>
</dd>
<dt>/usr/local/etc/unbound</dt><dd><p>default <em>chroot(2)</em> location.</p>
</dd>
<dt>/usr/local/etc/unbound/unbound.conf</dt><dd><p>Unbound configuration file.</p>
</dd>
<dt>/usr/local/etc/unbound/unbound.pid</dt><dd><p>default Unbound pidfile with process ID of the running daemon.</p>
</dd>
<dt>unbound.log</dt><dd><p>Unbound log file.
Default is to log to <em>syslog(3)</em>.</p>
</dd>
</dl>
</section>
<section id="see-also">
<h2>See Also<a class="headerlink" href="#see-also" title="この見出しへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="unbound.html"><span class="doc">unbound(8)</span></a>,
<a class="reference internal" href="unbound-checkconf.html"><span class="doc">unbound-checkonf(8)</span></a>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="unbound-checkconf.html" class="btn btn-neutral float-left" title="unbound-checkconf(8)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="unbound-host.html" class="btn btn-neutral float-right" title="unbound-host(1)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1999-2024, NLnet Labs.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>